
(*==========================================================*)
(* * Proofs *)

(************************************************************)
(* ** Properties of the semantics *)

(*todo: move *)
Ltac esplits := 
  esplit;
  repeat (match goal with |- exists _, _ => esplit end).

Definition get_out_trace o :=
  match o with
  | out_ter _ t => t
  | out_div t => t
  end.

Hint Constructors cored red.

Theorem red_cored : forall s d o,
  red s d o -> cored s d o.
Proof. introv H. induction* H. Qed.

Ltac testi H :=
  match type of H with cored ?s ?d ?o => tests: (red s d o) end.

Hint Constructors abort.

(*
Lemma cored_not_red_not_ter : forall s d o,
  cored s d o -> ~ red s d o -> cored s d (out_div (get_out_trace o)).
Proof.
  cofix IH. introv R N. inverts R as.
  introv E. false* N.
  introv R1 R2. testi R1.
    constructors*. 
    constructors~. inverts R2. applys* IH.

      constructors*. applys* IH. intros M. false* N. constructors. eauto. 

 inverts N1. applys N. constructors.

  skip.
  inverts R as. 
    introv A. apply E.
    intros o1 R1 E1. destruct o1 as [|t1]. false.
     simpls. inverts E1.
     lets: IH R1.
 unfolds out_prepend.

*)


Definition ext_nodiv d := 
  match d with
  | ext_seq_1 (out_div t) c => False
  | ext_seq_1 (out_ter s t) c => colist_finite t
  | _ => True
  end.

Lemma red_trace_finite : forall s d o,
  red s d o -> ext_nodiv d -> 
  exists s t, o = out_ter s t /\ colist_finite t /\ t <> colist_nil.
Proof.
  introv R. induction R; introv D; simpls.
  esplits. splits*. applys colist_one_not_nil.
  forwards* (?&?&?&?&?): IHR1. subst. forwards* (?&?&?&?&?): IHR2.
  inverts H. false.
  forwards* (?&?&?&?&?): IHR. subst. esplits. splits*. 
   applys~ colist_append_to_not_nil.
  forwards* (?&?&?&?&?): IHR. subst.
   esplits. splits*. applys colist_one_not_nil.
  forwards* (?&?&?&?&?): IHR.
Qed.

Definition ext_div_infinite d := 
  match d with
  | ext_seq_1 (out_div t) c => colist_infinite t
  | ext_seq_1 (out_ter s t) c => t <> colist_nil
  | _ => True
  end.

Lemma cored_trace_infinite : forall s d t,
  cored s d (out_div t) -> ext_div_infinite d -> colist_infinite t.
Proof.
  cofix IH. introv R E. destruct d.
  skip.
  inverts R as. 
    introv A. apply E.
    intros o1 R1 E1. destruct o1 as [|t1]. false.
     simpls. inverts E1.
     lets: IH R1.
 unfolds out_prepend.
Admitted.


(* useless
Lemma sc_observable_ter :
  sc_observable h ts r ->
  Forall colist_finite ts ->
  r <> res_div.
*)



  | red_app_2_match : forall oy p i t3 v2 m m0 o,
      matching i v2 p ->
      red m (ext_app_3 i oy t3) o ->
      red m0 (ext_app_2 (out_beh m (val_clo oy p t3) v2) o



  | red_app_3_none : forall i t3 m o,
      red m (substs i t3) o ->
      red m (ext_app_3 i None t3) o
  | red_app_3_some : forall i t3 m o,
      red m (subst y (val_abs (Some y) p t3) (substs i t3)) o ->
      red m (ext_app_3 i (Some y) t3) o


  | red_unary_1_abort : forall f m o,
      abort o ->
      red m (trm_unary_1 f o) o
  | red_binary_1_abort : forall f m o,
      abort o ->
      red m (trm_binary_1 f o t2) o
  | red_lazy_binary_1_abort : forall f m o,
      abort o ->
      red m (trm_unary_1 f o) o
  | red_app_1_abort : forall m o t2,
      abort o ->
      red m (ext_app_1 o t2) o
  | red_app_2_abort : forall v1 o2,
      abort o2 ->
      red (ext_app_2 v1 o2) o2
  | red_seq_1_abort : forall m o t2,
      abort o ->
      red m (ext_seq_1 o t2) o




  | ext_app_3 : inst -> option var -> trm -> ext


(*
Fixpoint subst (x:var) (v:val) (t:trm) : trm :=
  let s := subst x v in
  match t with
  | trm_val v => t
  | trm_var y => If x = y then trm_val v else t
  | trm_abs y t3 => trm_abs y (If x = y then t3 else s t3)
  | trm_app t1 t2 => trm_app (s t1) (s t2)  
  end.
*)



(* TODO
Notation "'trm_raise' t" := (trm_unary prim_raise t) (at level 60).
*)

(*todo move
Parameter MemAssoc : forall A B, list (A*B) -> A -> Prop.
*)

(*
Inductive unary_red : mem -> prim -> val -> out -> Prop :=
  | unary_red_not : forall m f (r:bool) o,
      unary_red m prim_neg r (out_beh m (neg r))
  | unary_red_neg : forall m f (n:int) o,
      unary_red m prim_not n (out_beh m (-n)).
*)


Coercion ctx_apply : ctx >-> Funclass.


(** Grammar of unary primitive operators *)

Inductive unop : Type :=  
  | unop_raise : unop
  | unop_not : unop
  | unop_neg : unop.

(** Grammar of unary binary operators *)

Inductive binop : Type :=  
  | binop_eq : binop
  | binop_and : binop
  | binop_or : binop
  | binop_add : binop
  | binop_sub : binop
  | binop_mul : binop
  | binop_div : binop.



(** Extracting one observation from a list of traces *)

Inductive extract_buffer : (word*word) -> buffers -> buffers -> Prop :=
  | extract_buffer_here : forall w b bs bs', 
      extract_buffer w ((w::b)::bs) (b::bs')
  | extract_buffer_next : forall w b bs bs', 
      extract_buffer w bs bs' ->
      extract_buffer w (b::bs) (b::bs').

(** Singleton trace containing none *)

Definition trace_skip : trace :=
  colist_one obs_none.


Inductive exec : stack -> act -> word -> obs -> Prop :=
  | exec_

  | act_comp : exp -> act
  | act_load : exp -> act
  | act_store : exp -> exp -> act
  | act_cas : exp -> exp -> exp -> act
  | act_fence : act.

Definition exec s a := 
  let r := eval s in
  match a with
  | act_comp e => (r e, obs_none)
  | act_load e => obs_load 

  | act_comp : exp -> act
  | act_load : exp -> act
  | act_store : exp -> exp -> act
  | act_cas : exp -> exp -> exp -> act
  | act_fence : act.



(*
Ltac build_ctx_for t :=
  let r t' := build_ctx_for t' in
  match t with
  | trm_app t1 t2 => 
    match t1 with
    | trm_val v1 => ctx_app_1 t1 (build_ctx_for t2)
    | _ => let c := (r t1) in constr:(ctx_app_1 c t2)
    end
  | _ => ctx_hole
  end.

  | ctx_hole : ctx
  | ctx_app_1 : ctx -> trm -> ctx
  | ctx_app_2 : val -> ctx -> ctx
  | ctx_case : ctx -> trm -> trm -> ctx
  | ctx_inj : bool -> ctx -> ctx
  | ctx_try : ctx -> trm -> ctx
  | ctx_raise : ctx -> ctx.
*)

(* Conversion function from behavior to outcomes *)

Coercion beh_out (b:beh) := 
  match b with
  | beh_ret v => out_ret v
  | beh_exn v => out_exn v
  end.

(** [bigred] to [red] *)

Lemma bigred_red : forall t b,
  bigred t b -> red t b.
Proof. introv H. induction H; simpls*. Qed.

(** [red] to [bigred] *)

Section RedBigred.

Lemma redh_not_div : forall n t,
  redh n t out_div -> False.
Proof. introv H. applys red_trm_not_div. applys* redh_red. Qed.

Hint Extern 1 (bigred _ out_div) =>
  match goal with H: redh _ _ out_div |- _ => 
    false redh_not_div end.

Tactic Notation "simpl_beh" hyp(E) := 
  match type of E with _ = beh_out ?b =>
    destruct b; simpls; inverts E end.

Tactic Notation "simpl_beh" := 
  match goal with H: _ = beh_out _ |- _ => simpl_beh H end.

Tactic Notation "simpl_beh" "*" := 
  simpl_beh; auto_star.

Lemma red_bigred : forall t b,
  red t b -> bigred t b.
Proof.
  introv R. forwards (n&R'): red_redh (rm R).
  gen b t. induction n using peano_induction.
  asserts IH: (forall m t b, redh m t b -> m < n -> bigred t b).
    intros. apply* H.
  clear H. introv R. inverts R as; try solve [ intros; simpl_beh* ]. 
  introv R1 R2. inverts R2 as.
    introv O. inverts O; simpl_beh*.
    introv R2 R3. inverts R3 as.
      introv O. inverts O; simpl_beh*.
      auto*.
  introv R1 R2. inverts R2; try simpl_beh*. applys* bigred_try_1.
  introv R1 R2. inverts R2 as.
    introv O. inverts O; simpl_beh*.
    intros; simpl_beh*. 
Qed.
 
End RedBigred.

(** [bigdiv] to [diverge] *)

Corollary bigred_cored : forall t b,
  bigred t b -> cored t b.
Proof. intros. apply red_cored. apply~ bigred_red. Qed.

Hint Extern 1 (cored _ _) => simpl.

Lemma bigdiv_diverge : forall t,
  bigdiv t -> diverge t.
Proof.
  hint bigred_cored.
  unfold diverge. cofix IH. introv H.
  inverts H; try solve [constructors*].
  (* Note: bug of eauto that should solve this *)
  constructors*. constructors*.
Qed.

(** [diverge] to [bigdiv] *)

Lemma diverge_bigdiv : forall t,
  diverge t -> bigdiv t.
Proof.
  hint red_bigred.
  cofix IH. introv R. inverts R as.
  introv R1 R2. destruct~ (cored_to_diverge_or_red R1).
    apply* bigdiv_app_1.
    inverts R2 as.
      intros. apply~ bigdiv_app_1.
      introv R2 R3. destruct~ (cored_to_diverge_or_red R2).
        apply* bigdiv_app_2. 
        inverts R3 as.
          intros. apply* bigdiv_app_2.
          introv R3. apply* bigdiv_app_3.
  introv R1 R2. destruct~ (cored_to_diverge_or_red R1).
    constructors*.
    inverts R2.
      apply* bigdiv_try_2.
      apply* bigdiv_try_1.
  introv R1 R2. destruct~ (cored_to_diverge_or_red R1).
    constructors*.
    inverts R2. constructors*.
Qed.


(************************************************************
* Lambda-calculus with exceptions,                          *
* Combined pretty-big-step semantics                        *
*************************************************************)

Set Implicit Arguments.
Require Import LambdaExn_Pretty.

Implicit Types v : val.
Implicit Types t : trm.
Implicit Types e : ext.
Implicit Types o : out.


(*==========================================================*)
(* * Definitions *)

(************************************************************)
(* ** Semantics *)

(************************************************************)
(* * Definitions *)

(** Non-regular behaviors *)

Inductive abort : out -> Prop :=
  | abort_exn : forall n v, 
     abort (out_ter n (beh_exn v))
  | abort_div : 
     abort out_div.

(** Partial order on the outcomes *)

Implicit Types n : nat.

Inductive faster : binary out :=
  | faster_ter : forall n n' r r',
      n < n' ->
      faster (out_ter n r) (out_ter n' r')
  | faster_div : forall o,
      faster o out_div.

Inductive before : binary out :=
  | before_ter : forall n n' r,
      n < n' ->
      before (out_ter n r) (out_ter n' r)
  | before_div : 
      before out_div out_div.

(** Optimization for automation:
    instead of writing two premises
    [faster o1 o -> before o2 o -> ..]
    we use a combined premise as follows. *)

Definition faster_before o1 o2 o :=
  before o2 o /\ faster o1 o.

(** Reduction *)

CoInductive red : ext -> out -> Prop :=
  | red_val : forall n v,
      red v (out_ter n v)
  | red_abs : forall n x t,
      red (trm_abs x t) (out_ter n (val_clo x t))
  | red_app : forall o1 o2 o t1 t2,
      red t1 o1 -> 
      red (ext_app_1 o1 t2) o2 -> 
      faster_before o1 o2 o ->
      red (trm_app t1 t2) o
  | red_app_1_abort : forall o1 o t2,
      abort o1 ->
      before o1 o ->
      red (ext_app_1 o1 t2) o
  | red_app_1 : forall o2 o3 o n v1 t2,
      red t2 o2 -> 
      red (ext_app_2 v1 o2) o3 -> 
      faster_before o2 o3 o ->
      red (ext_app_1 (out_ter n v1) t2) o
  | red_app_2_abort : forall o2 v1 o,
      abort o2 ->
      before o2 o ->
      red (ext_app_2 v1 o2) o
  | red_app_2 : forall o3 o n x t3 v2,
      red (subst x v2 t3) o3 -> 
      before o3 o ->
      red (ext_app_2 (val_clo x t3) (out_ter n v2)) o
  | red_try : forall o1 o2 t1 t2 o,
      red t1 o1 -> 
      red (ext_try_1 o1 t2) o2 -> 
      faster_before o1 o2 o ->
      red (trm_try t1 t2) o
  | red_try_1_val : forall n n' v1 t2,
      red (ext_try_1 (out_ter n v1) t2) (out_ter n' v1)
  | red_try_1_exn : forall o1 n v1 t2 o,
      red (trm_app t2 v1) o1 -> 
      before o1 o ->
      red (ext_try_1 (out_ter n (beh_exn v1)) t2) o
  | red_try_1_div : forall t2,
      red (ext_try_1 out_div t2) out_div
  | red_raise : forall o1 o2 t1 o,
      red t1 o1 ->
      red (ext_raise_1 o1) o2 ->
      faster_before o1 o2 o ->
      red (trm_raise t1) o
  | red_raise_1_abort : forall o1 o,
      abort o1 ->
      before o1 o ->
      red (ext_raise_1 o1) o
  | red_raise_1 : forall n n' v1,
      red (ext_raise_1 (out_ter n v1)) (out_ter n' (beh_exn v1))
  | red_rand : forall n k,
      (ParamDeterministic -> k = 0) ->
      red trm_rand (out_ter n (val_int k)).

Definition reds e b := exists n, red e (out_ter n b).

Definition divs e := red e out_div.


(************************************************************)
(* * Facts *)

Hint Constructors abort red faster before.
Hint Extern 1 (_ < _) => math.
Hint Extern 1 (_ <= _) => math.

(** Properties of partial order *)

Lemma faster_le_l : forall o n n' b,
  faster o (out_ter n b) -> n <= n' -> faster o (out_ter n' b).
Proof. introv O L. inverts* O. Qed.

Lemma before_le_l : forall o n n' b,
  before o (out_ter n b) -> n <= n' -> before o (out_ter n' b).
Proof. introv O L. inverts* O. Qed.

Lemma faster_before_le_l : forall o1 o2 n n' b,
  faster_before o1 o2 (out_ter n b) -> n <= n' -> 
  faster_before o1 o2 (out_ter n' b).
Proof.  
  hint faster_le_l, before_le_l.
  unfold faster_before. introv [O1 O2] L. split*. 
Qed.

Hint Resolve faster_before_le_l.

(** Automation for the partial order *)

Lemma faster_succ : forall n b,
  faster (out_ter n b) (out_ter (S n) b).
Proof. intros. auto. Qed.

Lemma before_succ : forall n b,
  before (out_ter n b) (out_ter (S n) b).
Proof. intros. auto. Qed.

Hint Extern 1 (before _ _) => apply before_succ.
Hint Extern 1 (faster _ _) => apply faster_succ.
Hint Extern 3 (faster_before _ _ _) => split.

(** Other automation not needed here *)

Section OtherAutomation.

Lemma faster_before_max : forall n1 n2 b1 b2,
  faster_before (out_ter n1 b1) (out_ter n2 b2) 
                (out_ter (S (max n1 n2)) b2).
Proof. 
  intros. forwards [[? ?]|[? ?]]: max_cases n1 n2; split~. 
Qed.

Ltac max_resolve :=
  simpl; match goal with |- context [max ?n1 ?n2] =>
    let e := fresh "m" in
    destruct (max_cases n1 n2) as [[? ?]|[? ?]];
    set (e := max n1 n2) in *; clearbody e end.

Hint Resolve faster_before_max.
Hint Extern 1 (before _ _) => max_resolve; constructor.
Hint Extern 1 (faster_before _ _ _) => apply faster_before_max.
End OtherAutomation.


(************************************************************)
(* * Determinacy *)

Section Det.

(** We assume that [trm_rand] always returns zero *)

Variables Det : ParamDeterministic.

(** Statement of [deterministic] *)

Inductive equiv : binary out :=
  | equiv_ter : forall n n' b,
      equiv (out_ter n b) (out_ter n' b)
  | equiv_div : 
      equiv out_div out_div.

Definition deterministic := forall e o1 o2,
  red e o1 -> red e o2 -> equiv o1 o2.

(** Proof of deterministic *)

Inductive ext_equiv : binary ext :=
  | ext_equiv_trm : forall t,
      ext_equiv t t
  | ext_equiv_app_1 : forall o1 o2 t,
      equiv o1 o2 ->
      ext_equiv (ext_app_1 o1 t) (ext_app_1 o2 t)
  | ext_equiv_app_2 : forall o1 o2 v,
      equiv o1 o2 ->
      ext_equiv (ext_app_2 v o1) (ext_app_2 v o2)
  | ext_equiv_try_1 : forall o1 o2 t,
      equiv o1 o2 ->
      ext_equiv (ext_try_1 o1 t) (ext_try_1 o2 t)
  | ext_equiv_raise_1 : forall o1 o2,
      equiv o1 o2 ->
      ext_equiv (ext_raise_1 o1) (ext_raise_1 o2).

Hint Constructors equiv ext_equiv.

Lemma equiv_refl : refl equiv.
Proof. intros o. destruct~ o. Qed.

Hint Resolve equiv_refl.

Lemma ext_equiv_refl : refl ext_equiv.
Proof. intros e. destruct~ e. Qed.

Hint Resolve ext_equiv_refl.

Ltac inverts2 E := 
  let H := fresh "X" in inverts E as H; inverts H.

Lemma det_ter_any : forall n e e' b o,
  red e (out_ter n b) -> red e' o -> ext_equiv e e' ->
  exists n', o = out_ter n' b.
Proof.
  induction n using peano_induction.
  asserts IH: (forall e e' b o m,
    red e (out_ter m b) -> red e' o -> ext_equiv e e' ->
    m < n -> exists n', o = out_ter n' b).
    intros. applys* H. clear H.
  introv R S E. inverts R as.
  inverts E. inverts* S.
  inverts E. inverts* S.
  skip.
  introv A B. inverts B. inverts2 E. inverts A;
    inverts S as A' B'; inverts B'; eauto.
  skip.
  introv A B. inverts B. inverts2 E. inverts A;
    inverts S as A' B'; inverts B'; eauto.
  introv R1 L1. inverts L1. inverts2 E. inverts S as.
    introv A B. inverts A.
    introv S1 M1. forwards~ (n1'&N1): IH R1 S1. subst. inverts* M1.
  introv R1 R2 [L2 L1]. inverts E. inverts S as S1 S2 [M2 M1].
   inverts L1. inverts L2.
   forwards~ (n1'&N1): IH R1 S1. subst.
   forwards~ (n2'&N2): IH R2 S2. subst.
   inverts M2. eauto.
  inverts2 E. inverts* S.
  introv R1 L1. inverts L1. inverts2 E. inverts S as S1 M1.
   forwards~ (n1'&N1): IH R1 S1. subst. inverts* M1.
  introv R1 R2 [L2 L1]. inverts E. inverts S as S1 S2 [M2 M1].
   inverts L1. inverts L2.
   forwards~ (n1'&N1): IH R1 S1. subst.
   forwards~ (n2'&N2): IH R2 S2. subst.
   inverts M2. eauto.
  introv A B. inverts B. inverts2 E. inverts A;
    inverts S as A' B'; inverts B'; eauto.
  inverts2 E. inverts S as.
    introv A B. inverts A.
    eauto.
  introv D. inverts E. inverts S as D'. rewrite~ D. rewrite* D'.
Qed.

Lemma deterministic_prove : deterministic.
Proof.
  introv R1 R2. destruct o1; destruct o2.
  forwards~ (n3&M): det_ter_any R1 R2. inverts~ M.
  forwards~ (?&M): det_ter_any R1 R2. inverts~ M.
  forwards~ (?&M): det_ter_any R2 R1. inverts~ M.
  constructor.
Qed.  

(** Bonus *)

Corollary det_ter_ter : forall e n1 n2 b1 b2,
  red e (out_ter n1 b1) -> red e (out_ter n2 b2) -> b1 = b2.
Proof.
  introv R1 R2. forwards~ (?&M): det_ter_any R1 R2. inverts~ M.
Qed.  

Corollary det_ter_div : forall e n b,
  red e (out_ter n b) -> red e out_div -> False.
Proof.
  introv R1 R2. forwards~ M: det_ter_any R1 R2. inverts M. false.
Qed.  

End Det.



(************************************************************)
(* * Equivalence with big-step *)

Hint Constructors bigred.

Definition red_raise_1' n := red_raise_1 n n.
Hint Resolve red_raise_1'.

Lemma bigred_reds : forall t b,
  bigred t b -> reds t b.
Proof. 
  unfold reds. introv H.
  forwards (n&M): bigred_bigredh (rm H).
  exists ((n+n+n+n)%nat).
  induction M; eauto; eauto 9.
Qed.

Lemma reds_bigred : forall t b,
  reds t b -> bigred t b.
Proof.
  introv (n&R). gen t b. induction n using peano_induction.
  asserts IH: (forall m t b, red t (out_ter m b) -> m < n -> bigred t b).
    auto*. clear H.
  introv R. inverts R as; auto.
  introv R1 R2 [L2 L1]. inverts L2. inverts L1. inverts R2 as.
     introv A B. inverts A. inverts* B.
     introv R3 R4 [L4 L3]. inverts L3. inverts L4. inverts R4 as.
       introv A B. inverts A. inverts* B.
       introv R5 L5. inverts* L5.
  introv R1 R2 [L2 L1]. inverts L2. inverts L1. inverts R2 as.
    constructors*.
    introv R3 L3. inverts* L3.
  introv R1 R2 [L2 L1]. inverts L2. inverts L1. inverts R2 as.
    introv A B. inverts A. inverts* B.
    constructors*.
Qed.
 
Corollary red_bigred : forall n t b,
  red t (out_ter n b) -> bigred t b.
Proof. introv R. apply* reds_bigred. exists* n. Qed.

Lemma bigdiv_divs : forall t,
  bigdiv t -> divs t.
Proof.
  introv R. unfold divs. gen t. cofix IH. 
  introv H. inverts H as.
  introv R1. constructors*. 
  introv R1 R2. forwards (n1&M1): bigred_reds R1. constructors*.
  introv R1 R2 R3. forwards (n1&M1): bigred_reds R1.
    forwards (n2&M2): bigred_reds R2. constructors*.
  introv R1. constructors*.   
  introv R1 R2. forwards (n1&M1): bigred_reds R1. constructors*.
  introv R1. constructors*.   
Qed.

Lemma divs_bigdiv : forall t,
  divs t -> bigdiv t.
Proof.
  hint red_bigred. unfolds divs. cofix IH.
  introv R. inverts R as R1 R2 [L2 L1].
  inverts L2. inverts R2 as.
    introv A B. inverts B. applys* bigdiv_app_1.
    introv R3 R4 [L4 L3]. inverts L4. inverts R4 as.
      introv A B. inverts B. apply* bigdiv_app_2.
      introv R5 L5. inverts L5. apply* bigdiv_app_3.
  inverts L2. inverts R2 as.
    introv R5 L5. inverts L5. apply* bigdiv_try_2.
  apply* bigdiv_try_1.
  inverts L2. inverts R2 as.
   introv A B. inverts B. apply* bigdiv_raise_1.
Qed.



(************************************************************
* Lambda-calculus with exceptions,                          *
* Pretty-big-step semantics                                 *
*************************************************************)

Set Implicit Arguments.
Require Export LambdaExn_Syntax.

Implicit Types v : val.
Implicit Types t : trm.


(*==========================================================*)
(* * Definitions *)

(************************************************************)
(* ** Semantics *)

(** Grammar of outcomes *)

Inductive out :=
  | out_ret : val -> out
  | out_exn : val -> out
  | out_div : out.

Coercion out_ret : val >-> out.

Implicit Types o : out.

(** Grammar of extended terms *)

Inductive ext : Type :=
  | ext_trm : trm -> ext
  | ext_app_1 : out -> trm -> ext
  | ext_app_2 : val -> out -> ext
  | ext_try_1 : out -> trm -> ext
  | ext_raise_1 : out -> ext.

Coercion ext_trm : trm >-> ext.
Implicit Types e : ext.

(** Abort behavior *)

Inductive abort : out -> Prop :=
  | abort_exn : forall v, abort (out_exn v)
  | abort_div : abort out_div.

(** Evaluation judgment *)

Inductive red : ext -> out -> Prop :=
  | red_val : forall v,
      red v v
  | red_abs : forall x t,
      red (trm_abs x t) (val_clo x t)
  | red_app : forall t1 t2 o1 o2,
      red t1 o1 ->
      red (ext_app_1 o1 t2) o2 ->
      red (trm_app t1 t2) o2
  | red_app_1_abort : forall o1 t2,
      abort o1 ->
      red (ext_app_1 o1 t2) o1
  | red_app_1_clo : forall v1 t2 o o2,
      red t2 o2 ->
      red (ext_app_2 v1 o2) o ->
      red (ext_app_1 v1 t2) o
  | red_app_2_abort : forall v1 o2,
      abort o2 ->
      red (ext_app_2 v1 o2) o2
  | red_app_2_beta : forall x t3 v2 o,
      red (subst x v2 t3) o ->
      red (ext_app_2 (val_clo x t3) v2) o
  | red_try : forall t1 t2 o1 o,
      red t1 o1 ->
      red (ext_try_1 o1 t2) o ->
      red (trm_try t1 t2) o
  | red_try_1_success : forall v1 t2,
      red (ext_try_1 v1 t2) v1
  | red_try_1_fault : forall t2 o v,
      red (trm_app t2 v) o ->
      red (ext_try_1 (out_exn v) t2) o
  | red_try_1_diverge : forall t2,
      red (ext_try_1 out_div t2) out_div
  | red_raise : forall t1 o1 o,
      red t1 o1 ->
      red (ext_raise_1 o1) o ->
      red (trm_raise t1) o
  | red_raise_1_abort : forall o1,
      abort o1 ->
      red (ext_raise_1 o1) o1
  | red_raise_1 : forall v,
      red (ext_raise_1 v) (out_exn v)
  | red_rand : forall k, 
      (ParamDeterministic -> k = 0) ->
      red trm_rand (val_int k).


(** Coevaluation judgment:
    copy-paste of the above definition, 
    simply replacing [red] with [cored] *)

CoInductive cored : ext -> out -> Prop :=
  | cored_val : forall v,
      cored v v
  | cored_abs : forall x t,
      cored (trm_abs x t) (val_clo x t)
  | cored_app : forall t1 t2 o1 o2,
      cored t1 o1 ->
      cored (ext_app_1 o1 t2) o2 ->
      cored (trm_app t1 t2) o2
  | cored_app_1_abort : forall o1 t2,
      abort o1 ->
      cored (ext_app_1 o1 t2) o1
  | cored_app_1_clo : forall v1 t2 o o2,
      cored t2 o2 ->
      cored (ext_app_2 v1 o2) o ->
      cored (ext_app_1 v1 t2) o
  | cored_app_2_abort : forall v1 o2,
      abort o2 ->
      cored (ext_app_2 v1 o2) o2
  | cored_app_2_beta : forall x t3 v2 o,
      cored (subst x v2 t3) o ->
      cored (ext_app_2 (val_clo x t3) v2) o
  | cored_try : forall t1 t2 o1 o,
      cored t1 o1 ->
      cored (ext_try_1 o1 t2) o ->
      cored (trm_try t1 t2) o
  | cored_try_1_success : forall v1 t2,
      cored (ext_try_1 v1 t2) v1
  | cored_try_1_fault : forall t2 o v,
      cored (trm_app t2 v) o ->
      cored (ext_try_1 (out_exn v) t2) o
  | cored_try_1_diverge : forall t2,
      cored (ext_try_1 out_div t2) out_div
  | cored_raise : forall t1 o1 o,
      cored t1 o1 ->
      cored (ext_raise_1 o1) o ->
      cored (trm_raise t1) o
  | cored_raise_1_abort : forall o1,
      abort o1 ->
      cored (ext_raise_1 o1) o1
  | cored_raise_1 : forall v,
      cored (ext_raise_1 v) (out_exn v)
  | cored_rand : forall k, 
      (ParamDeterministic -> k = 0) ->
      cored trm_rand (val_int k).

(** Definition of divergence *)

Definition diverge e := cored e out_div.


(*==========================================================*)
(* * Proofs *)

(************************************************************)
(* ** Basic properties of the semantics *)

Hint Constructors red cored abort.

(** Proof that [cored] contains [red] *)

Theorem red_cored : forall e o,
  red e o -> cored e o.
Proof. introv H. induction* H. Qed.

(** Proof that [red e out_div -> False] *)

Definition ext_not_diverge e :=
  let n o := o <> out_div in
  match e with
  | ext_trm _ => True
  | ext_app_1 o1 t2 => n o1
  | ext_app_2 v1 o2 => n o2
  | ext_try_1 o1 t2 => n o1
  | ext_raise_1 o1 => n o1
  end.

Hint Unfold ext_not_diverge.

Hint Extern 1 (_ <> _) => congruence.

Lemma red_not_div : forall e o,
  red e o -> ext_not_diverge e -> o <> out_div.
Proof. introv H. induction* H. Qed.

Lemma red_trm_not_div' : forall t o,
  red (ext_trm t) o -> o <> out_div.
Proof. introv H. apply* red_not_div. Qed.

Lemma red_trm_not_div : forall t,
  red (ext_trm t) out_div -> False. 
Proof. introv M. applys* red_trm_not_div' M. Qed.

(** Proof that [cored] implies [red] or [diverge] *)

Ltac doi_base :=
  match goal with IH: forall _, _ |- _ =>
    eapply IH
  end;
  [ eauto | instantiate; intros ?;
    match goal with N: ~ red _ _ |- _  => false N end ].

Ltac doi := doi_base; eauto.

Ltac testi H :=
  match type of H with cored ?e ?o => tests: (red e o) end.

Lemma cored_not_red_diverge : forall e o,
  cored e o -> ~ red e o -> diverge e.
Proof.
  unfold diverge. cofix IH. introv C R.
  inverts C; try solve [ false* R ]. 
  testi H.
    constructors*.
    constructors~. apply* IH.
  testi H. 
    constructors*.
    constructors~. apply* IH.
  constructors*.
  testi H.
    destruct o1. 
      constructors*.
      constructors*.
      constructors*.
    constructors~. apply* IH.
  constructors. doi.
  testi H.
    constructors*.
    constructors~. apply* IH.
Qed.

Corollary cored_not_diverge_red : forall e o,
  cored e o -> ~ diverge e -> red e o.
Proof.
  introv C D. apply not_not_elim. intros R.
  apply D. applys* cored_not_red_diverge. 
Qed. 

Corollary cored_to_diverge_or_red : forall e o,
  cored e o -> diverge e \/ red e o.
Proof.
  introv C. apply classic_left. intros.
  applys* cored_not_red_diverge.
Qed.


(************************************************************)
(* ** Determinacy *)

(** Definition of deterministic *)

Definition deterministic := 
  forall e o1 o2, red e o1 -> cored e o2 -> o1 = o2.

(** Proof that the language is deterministic *)

Ltac off :=
  try solve [ match goal with
    H: abort _ |- _ => tryfalse_invert H
  end | false ].

Lemma red_cored_deterministic : 
  ParamDeterministic -> deterministic.
Proof.
  introv Det R C. gen o2. induction R; intros;
   inverts C; off; auto; try solve [ false; auto ].
  rewrite~ <- IHR2. erewrite* IHR1.
  rewrite~ <- IHR2. erewrite* IHR1.
  rewrite~ <- IHR2. erewrite* IHR1.
  rewrite~ <- IHR2. erewrite* IHR1.
  rewrite H, H0; auto.
Qed.

(** Corollary: [red] is deterministic *) 

Corollary red_deterministic : 
  ParamDeterministic -> 
  forall e o1 o2, red e o1 -> red e o2 -> o1 = o2.
Proof.
  introv D R1 R2. hint red_cored.
  applys* red_cored_deterministic.
Qed.

(** Corollary: termination and divergence are exclusive 
    for terms *) 

Corollary red_not_diverge_trm : 
  ParamDeterministic -> 
  forall t o, red t o -> diverge t -> False.
Proof.
  introv D R1 R2. forwards M: red_cored_deterministic D R1 R2.
  applys* red_trm_not_div' M.
Qed.

(** Note that for extended terms, the above result holds only 
    for those satisfying [ext_not_diverge] *)

Corollary red_not_diverge_ext : 
  ParamDeterministic -> 
  forall e o, red e o -> diverge e -> ext_not_diverge e -> False.
Proof.
  introv D R1 R2 N. forwards M: red_cored_deterministic D R1 R2.
  applys* red_not_div M.
Qed.


(************************************************************)
(* ** Induction principle on the height of a derivation *)

(** Ideally, would be automatically generated by Coq *)

Hint Constructors red cored.

(** Copy-paste of the definition of [red], plus a depth counter *)

Inductive redh : nat -> ext -> out -> Prop :=
  | redh_val : forall n v,
      redh (S n) v v
  | redh_abs : forall n x t,
      redh (S n) (trm_abs x t) (val_clo x t)
  | redh_app : forall n t1 t2 o1 o2,
      redh n t1 o1 ->
      redh n (ext_app_1 o1 t2) o2 ->
      redh (S n) (trm_app t1 t2) o2
  | redh_app_1_abort : forall n o1 t2,
      abort o1 ->
      redh (S n) (ext_app_1 o1 t2) o1
  | redh_app_1_clo : forall n v1 t2 o o2,
      redh n t2 o2 ->
      redh n (ext_app_2 v1 o2) o ->
      redh (S n) (ext_app_1 v1 t2) o
  | redh_app_2_abort : forall n v1 o2,
      abort o2 ->
      redh (S n) (ext_app_2 v1 o2) o2
  | redh_app_2_beta : forall n x t3 v2 o,
      redh n (subst x v2 t3) o ->
      redh (S n) (ext_app_2 (val_clo x t3) v2) o
  | redh_try : forall n t1 t2 o1 o,
      redh n t1 o1 ->
      redh n (ext_try_1 o1 t2) o ->
      redh (S n) (trm_try t1 t2) o
  | redh_try_1_success : forall n v1 t2,
      redh (S n) (ext_try_1 v1 t2) v1
  | redh_try_1_fault : forall n t2 o v,
      redh n (trm_app t2 v) o ->
      redh (S n) (ext_try_1 (out_exn v) t2) o
  | redh_try_1_diverge : forall n t2,
      redh (S n) (ext_try_1 out_div t2) out_div
  | redh_raise : forall n t1 o1 o,
      redh n t1 o1 ->
      redh n (ext_raise_1 o1) o ->
      redh (S n) (trm_raise t1) o
  | redh_raise_1_abort : forall n o1,
      abort o1 ->
      redh (S n) (ext_raise_1 o1) o1
  | redh_raise_1 : forall n v,
      redh (S n) (ext_raise_1 v) (out_exn v)
  | redh_rand : forall n k, 
      (ParamDeterministic -> k = 0) ->
      redh (S n) trm_rand (val_int k).

Hint Constructors redh.
Hint Extern 1 (_ < _) => math.

Lemma redh_lt : forall n n' e o,
  redh n e o -> n < n' -> redh n' e o.
Proof.
  introv H. gen n'. induction H; introv L; 
   (destruct n' as [|n']; [ false; math | auto* ]).
Qed.

Lemma red_redh : forall e o, 
  red e o -> exists n, redh n e o.
Proof.
  hint redh_lt. introv H. induction H; try induct_height.
Qed.

Lemma redh_red : forall n e o,
  redh n e o -> red e o.
Proof. introv H. induction* H. Qed.
 

(************************************************************)
(* ** Equivalence with the traditional big-step semantics *)

Require Import LambdaExn_Big.
Hint Constructors bigred.
Implicit Types b : beh.

(* Conversion function from behavior to outcomes *)

Coercion beh_out (b:beh) := 
  match b with
  | beh_ret v => out_ret v
  | beh_exn v => out_exn v
  end.

(** [bigred] to [red] *)

Lemma bigred_red : forall t b,
  bigred t b -> red t b.
Proof. introv H. induction H; simpls*. Qed.

(** [red] to [bigred] *)

Section RedBigred.

Lemma redh_not_div : forall n t,
  redh n t out_div -> False.
Proof. introv H. applys red_trm_not_div. applys* redh_red. Qed.

Hint Extern 1 (bigred _ out_div) =>
  match goal with H: redh _ _ out_div |- _ => 
    false redh_not_div end.

Tactic Notation "simpl_beh" hyp(E) := 
  match type of E with _ = beh_out ?b =>
    destruct b; simpls; inverts E end.

Tactic Notation "simpl_beh" := 
  match goal with H: _ = beh_out _ |- _ => simpl_beh H end.

Tactic Notation "simpl_beh" "*" := 
  simpl_beh; auto_star.

Lemma red_bigred : forall t b,
  red t b -> bigred t b.
Proof.
  introv R. forwards (n&R'): red_redh (rm R).
  gen b t. induction n using peano_induction.
  asserts IH: (forall m t b, redh m t b -> m < n -> bigred t b).
    intros. apply* H.
  clear H. introv R. inverts R as; try solve [ intros; simpl_beh* ]. 
  introv R1 R2. inverts R2 as.
    introv O. inverts O; simpl_beh*.
    introv R2 R3. inverts R3 as.
      introv O. inverts O; simpl_beh*.
      auto*.
  introv R1 R2. inverts R2; try simpl_beh*. applys* bigred_try_1.
  introv R1 R2. inverts R2 as.
    introv O. inverts O; simpl_beh*.
    intros; simpl_beh*. 
Qed.
 
End RedBigred.

(** [bigdiv] to [diverge] *)

Corollary bigred_cored : forall t b,
  bigred t b -> cored t b.
Proof. intros. apply red_cored. apply~ bigred_red. Qed.

Hint Extern 1 (cored _ _) => simpl.

Lemma bigdiv_diverge : forall t,
  bigdiv t -> diverge t.
Proof.
  hint bigred_cored.
  unfold diverge. cofix IH. introv H.
  inverts H; try solve [constructors*].
  (* Note: bug of eauto that should solve this *)
  constructors*. constructors*.
Qed.

(** [diverge] to [bigdiv] *)

Lemma diverge_bigdiv : forall t,
  diverge t -> bigdiv t.
Proof.
  hint red_bigred.
  cofix IH. introv R. inverts R as.
  introv R1 R2. destruct~ (cored_to_diverge_or_red R1).
    apply* bigdiv_app_1.
    inverts R2 as.
      intros. apply~ bigdiv_app_1.
      introv R2 R3. destruct~ (cored_to_diverge_or_red R2).
        apply* bigdiv_app_2. 
        inverts R3 as.
          intros. apply* bigdiv_app_2.
          introv R3. apply* bigdiv_app_3.
  introv R1 R2. destruct~ (cored_to_diverge_or_red R1).
    constructors*.
    inverts R2.
      apply* bigdiv_try_2.
      apply* bigdiv_try_1.
  introv R1 R2. destruct~ (cored_to_diverge_or_red R1).
    constructors*.
    inverts R2. constructors*.
Qed.


(*************************************************************)
(** Bonus: an inversion principle for divergence *)

CoInductive div : ext -> Prop :=
  | div_app_div : forall t1 t2,
      div t1 ->
      div (trm_app t1 t2) 
  | div_app : forall t1 t2 o1,
      red t1 o1 ->
      div (ext_app_1 o1 t2) ->
      div (trm_app t1 t2) 
  | div_app_1_abort : forall t2, 
      div (ext_app_1 out_div t2)  
  | div_app_1_div : forall v1 t2,
      div t2 ->
      div (ext_app_1 v1 t2) 
  | div_app_1_clo : forall v1 t2 o o2,
      red t2 o2 ->
      div (ext_app_2 v1 o2) ->
      div (ext_app_1 v1 t2) 
  | div_app_2_abort : forall v1,
      div (ext_app_2 v1 out_div) 
  | div_app_2_beta : forall x t3 v2,
      div (subst x v2 t3)  ->
      div (ext_app_2 (val_clo x t3) v2) 
  | div_try_div : forall t1 t2 o1 o,
      div t1 ->
      div (trm_try t1 t2) 
  | div_try : forall t1 t2 o1 o,
      red t1 o1 ->
      div (ext_try_1 o1 t2) ->
      div (trm_try t1 t2) 
  | div_try_1_fault : forall t2 v,
      div (trm_app t2 v) ->
      div (ext_try_1 (out_exn v) t2) 
  | div_try_1_div : forall t2,
      div (ext_try_1 out_div t2)
  | div_raise_div : forall t1,
      div t1 ->
      div (trm_raise t1)
  | div_raise : forall t1 o1,
      red t1 o1 ->
      div (ext_raise_1 o1) ->
      div (trm_raise t1)
  | div_raise_1_div :
      div (ext_raise_1 out_div).

Lemma div_diverge : forall e,
  div e -> diverge e.
Proof.
  hint red_cored.
  unfold diverge. cofix IH. introv R. 
  inverts R; try solve [constructors*].
Qed.

Lemma diverge_div : forall e,
  diverge e -> div e.
Proof.
  sets C: cored_to_diverge_or_red.
  unfold diverge. cofix IH. introv R. inverts R as.
  introv R1 R2. lets [?|?]: C R1.
    apply* div_app_div.
    apply* div_app.
  introv _. constructors.
  introv R1 R2. lets [?|?]: C R1.
    apply* div_app_1_div.
    apply* div_app_1_clo.
  introv _. constructors.
  introv R. constructors*.
  introv R1 R2. lets [?|?]: C R1.
    apply* div_try_div.
    apply* div_try.
  introv R. constructors*.
  constructors*.
  introv R1 R2. lets [?|?]: C R1.
    apply* div_raise_div.
    apply* div_raise.
  constructors*.
Qed.



---------------------





(************************************************************)
(* * Facts *)

Hint Constructors red.


(************************************************************)
(* * Derived reduction rules *)

Lemma red_inj_val : forall b v1,
   red (trm_inj b v1) (val_inj b v1).
Proof.
  intros. applys* red_inj.
Defined.

Lemma red_abs_beta : forall o x t3 v2,
   red (subst x v2 t3) o ->
   red (trm_app (trm_abs x t3) v2) o.
Proof.
  introv R. applys red_app. auto.
  applys red_app_1. auto. 
  applys red_app_2 R.
Defined.

Lemma red_abs_beta' : forall o x t3 v2,
   red (subst x v2 t3) o ->
   red (trm_app (val_abs x t3) v2) o.
Proof.
  introv R. applys red_app. auto.
  applys red_app_1. auto. 
  applys red_app_2 R. 
Defined.


(************************************************************)
(* * Freshness *)

(** Two modes for freshness: "not used" and "not free" *)

Inductive vars_opt := not_used | not_free.

Definition add_bound f E (x:var) :=
  match f with 
  | not_used => E \u \{x}
  | not_free => E \- \{x}
  end.

Lemma notin_add_bound : forall x f y E,
  x \notin add_bound f E y ->
  x \notin E \- \{y}.
Proof.
  intros. destruct f; simpls.
  applys~ notin_remove_weaken.
  auto.
Qed.

(** Set of free variables and used variables *)

Fixpoint trm_vars (f:vars_opt) (t:trm) : vars :=
  let r := trm_vars f in
  match t with
  | trm_val v1 => val_vars f v1
  | trm_var x => \{x}
  | trm_abs x t1 => add_bound f (r t1) x
  | trm_app t1 t2 => (r t1) \u (r t2)
  | trm_inj b t1 => (r t1)
  | trm_case t1 t2 t3 => (r t1) \u (r t2) \u (r t3)
  | trm_try t1 t2 => (r t1) \u (r t2)
  | trm_raise t1 => (r t1)
  end 

with val_vars (f:vars_opt) (v:val) : vars :=
  match v with
  | val_int n => \{}
  | val_abs x t1 => add_bound f (trm_vars f t1) x
  | val_inj b v1 => val_vars f v1
  end.

Definition out_vars (f:vars_opt) (o:out) :=
  match o with
  | out_ret v => val_vars f v
  | out_exn v => val_vars f v
  | out_div => \{}
  end.

Definition ext_vars (f:vars_opt) (e:ext) :=
  let trm_vars := trm_vars f in
  let out_vars := out_vars f in
  match e with
  | ext_trm t1 => trm_vars t1 
  | ext_app_1 o1 t1 => out_vars o1 \u trm_vars t1
  | ext_app_2 v1 o2 => trm_vars v1 \u out_vars o2
  | ext_inj_1 b o1 => out_vars o1
  | ext_case_1 o1 t2 t3 => out_vars o1 \u trm_vars t2 \u trm_vars t3
  | ext_try_1 o1 t2 => out_vars o1 \u trm_vars t2
  | ext_raise_1 o1 => out_vars o1
  end.

(** Substitution is the identity function on fresh vars *)

Lemma subst_id : forall f x v t, 
  x \notin trm_vars f t -> 
  subst x v t = t. 
Proof.
  induction t; introv F; simpls; fequals~.
  case_if*. notin_false.
  case_if*. applys IHt. destruct f; simpls~.
   applys~ notin_remove_inv F.
Qed.
  
Lemma subst_notin : forall t x y v,
  x \notin (trm_vars not_used t) ->
  x \notin (val_vars not_used v) ->
  x \notin (trm_vars not_used (subst y v t)).
Proof. induction t; introv Frt Frv; simpls~; try case_if*. Qed.

Lemma fresh_subst : forall xs n t y v,
  fresh (trm_vars not_used t) n xs ->
  fresh (val_vars not_used v) n xs ->
  fresh (trm_vars not_used (subst y v t)) n xs.
Proof. 
  induction xs; introv Frt Frv.
  auto.
  destruct n. false. simpls. 
   destruct Frt. destruct Frv.
   hint subst_notin. auto.
Qed.

(** Reduction of terms does not introduce new variables *)

Hint Extern 1 (_ \notin ext_vars _ _) => unfold ext_vars.

Lemma notin_red : forall o x e,
  red e o ->
  x \notin ext_vars not_used e ->
  x \notin out_vars not_used o.
Proof.
  introv R F. induction R; simpl in F.
  auto.
  auto.
  forwards~: IHR1. (* forwards~: IHR2. *)
  inverts H; simpls~.
  forwards~: IHR1. forwards~: IHR2.
  auto.
  forwards~: IHR. applys~ subst_notin. 
  forwards~: IHR1.
  auto.
  auto.
  forwards~: IHR1.
  auto.
  forwards~: IHR.
  forwards~: IHR.
  forwards~: IHR1.
  simple~.
  forwards~: IHR.
  simple~. 
  forwards~: IHR1.
  auto.
  auto.
Qed. 

Lemma fresh_red : forall m xs e o,
  red e o ->
  fresh (ext_vars not_used e) m xs ->
  fresh (out_vars not_used o) m xs.
Proof.
  introv R Fr. applys* notin_to_fresh.
  intros. applys* notin_red.
Qed.



(************************************************************)
(* * Translation of exceptions *)

(** Variables introduced by the translation *)

Parameter x1 x2 x3 : var.
Parameter x1_neq_x2 : x1 <> x2.
Parameter x1_neq_x3 : x1 <> x3.
Parameter x2_neq_x3 : x2 <> x3.

Definition L := x1::x2::x3::nil.
Lemma L_eq : L = x1::x2::x3::nil.
Proof. auto. Defined.
Opaque L.

Hint Resolve x1_neq_x2 x2_neq_x3 x1_neq_x3.

Hint Extern 1 (_ \notin _) => rewrite L_eq in *. 

Coercion trm_var : var >-> trm.

(** Definition of the translation *)

Definition tr_ret t := trm_inj true t.
Definition tr_exn t := trm_inj false t.

Definition tr_bind t' x k :=
  trm_case t' (trm_abs x k) (trm_abs x (tr_exn (trm_var x))).

Definition tr_cont t' :=
  trm_abs x2 (tr_bind t' x3 (trm_app x3 x2)).

Fixpoint tr_trm (t:trm) : trm := 
  let s := tr_trm in
  match t with
  | trm_val v => tr_ret (tr_val v)
  | trm_var y => tr_ret t
  | trm_abs y t3 => tr_ret (trm_abs y (s t3))
  | trm_app t1 t2 => 
      tr_bind (s t1) x1 
       (tr_bind (s t2) x2 
         (trm_app x1 x2))
  | trm_inj b t1 => 
      tr_bind (s t1) x1 (tr_ret (trm_inj b x1))
  | trm_case t1 t2 t3 => 
      tr_bind (s t1) x1 
       (trm_case x1 (tr_cont (s t2)) (tr_cont (s t3)))
  | trm_try t1 t2 => 
     trm_case (s t1) (trm_abs x1 (tr_ret x1)) 
                     (tr_cont (s t2))
  | trm_raise t1 => 
      tr_bind (s t1) x1 (tr_exn x1)
  end

with tr_val (v:val) : val := 
  match v with
  | val_abs y t3 => val_abs y (tr_trm t3)
  | val_inj b v1 => val_inj b (tr_val v1)
  | _ => v
  end.

Definition tr_out (o:out) :=
  match o with
  | out_ret v => out_ret (val_inj true (tr_val v))
  | out_exn v => out_ret (val_inj false (tr_val v))
  | out_div => out_div
  end.

(** Distribution of substitution over the translation *)

Ltac imp x :=
  try rewrite L_eq in *;
  asserts: (x \notin \{x}); [ auto | notin_false ]. 

Ltac imp_any :=
  solve [ imp x1 | imp x2 | imp x3 ].

Ltac neq_any :=
  solve [ false x1_neq_x2; assumption
        | false x1_neq_x3; assumption
        | false x2_neq_x3; assumption ].

Ltac simpl_subst :=
  repeat (case_if; try neq_any; try imp_any).

Lemma tr_val_subst : forall x v t, 
  fresh (trm_vars not_used t \u \{x}) 3 L ->
  tr_trm (subst x v t) = subst x (tr_val v) (tr_trm t).
Proof.
  induction t; introv F; simpls.
  fequals.
  simpl_subst; fequals.
  simpl_subst; fequals. rewrite~ IHt.
  simpl_subst. rewrite~ IHt1. rewrite~ IHt2.
  simpl_subst. rewrite~ IHt.
  simpl_subst. rewrite~ IHt1.
   rewrite~ IHt2. rewrite~ IHt3.
  simpl_subst. rewrite~ IHt1. rewrite~ IHt2.
  simpl_subst. rewrite~ IHt.
Qed.

Lemma subst_tr_bind : forall t x k y v,
  x <> y ->
    subst y v (tr_bind t x k) 
  = tr_bind (subst y v t) x (subst y v k).
Proof. introv N. simpl. case_if. fequals. Qed.

Lemma subst_tr_cont : forall t y v,
  fresh (\{y}) 2 (x2::x3::nil) ->
    subst y v (tr_cont t) 
  = tr_cont (subst y v t).
Proof. introv H. simpl. simpl_subst. fequals. Qed.

Lemma tr_trm_vars : forall t,
  fresh (trm_vars not_used t) 3 L ->
  fresh (trm_vars not_free (tr_trm t)) 3 L
with tr_val_vars : forall v,
  fresh (trm_vars not_used v) 3 L ->
  fresh (trm_vars not_free (tr_val v)) 3 L.
Proof.
  (* trm *)
  induction t; introv F; simpls.
  apply~ tr_val_vars.
  auto.
  applys~ fresh_remove_weaken.
  specializes~ IHt1. specializes~ IHt2. fset_simpl.
   do 2 (rewrite union_remove; [ | apply~ notin_elim_single ]).
   auto.
  specializes~ IHt. fset_simpl. auto.
  specializes~ IHt1. specializes~ IHt2. specializes~ IHt3.
   fset_simpl.
   rewrite (@union_remove' _ \{x2}); [ | apply~ notin_elim_single ]. 
   do 2 (rewrite union_remove; [ | apply~ notin_elim_single ]).
   rewrite union_remove'; [ | apply~ notin_elim_single ].
   auto.
  specializes~ IHt1. specializes~ IHt2. fset_simpl.
   rewrite union_remove'; [ | apply~ notin_elim_single ]. 
   rewrite union_remove; [ | apply~ notin_elim_single ]. 
   auto.
  specializes~ IHt. fset_simpl. auto.
  (* val *)
  induction v; introv F; simpls.
  auto.
  applys fresh_remove_weaken. applys~ tr_trm_vars.
  auto.
Qed.

(** Auxiliary definitions, lemmas and tactics *)

Ltac simpl_substs := simpl; case_if; tryfalse.

Definition correctness_red :=
  forall t o, red t o -> 
  fresh (trm_vars not_used t) 3 L ->
  red (tr_trm t) (tr_out o).

Definition correctness_cored :=
  forall t, diverge t -> 
  fresh (trm_vars not_used t) 3 L ->
  diverge (tr_trm t).

Ltac done := simpl; auto.

(** Verification of [tr_bind] *)



Lemma red_tr_bind_abort : forall o1 t1 x k,
  correctness_red -> 
  red t1 o1 ->
  abort o1 ->
  fresh (trm_vars not_used t1) 3 L ->
  red (tr_bind (tr_trm t1) x k) (tr_out o1).
Proof.
  introv C R A Fr. inverts A.
  applys red_case. applys* C.
   simpl. applys red_case_1_false.
   applys red_abs_beta. unfold tr_exn. simpl_substs.
   applys red_inj_val.
  false* red_trm_not_div.
Qed.

Hint Constructors abort.

Lemma cored_tr_bind_abort : forall t1 x k,
  correctness_cored -> 
  diverge t1 ->
  fresh (trm_vars not_used t1) 3 L ->
  diverge (tr_bind (tr_trm t1) x k).
Proof.
  introv C R Fr. 
  applys cored_case. applys* C.
  applys* cored_case_1_abort.
Defined.

Lemma red_tr_bind_ret : forall o t1 v1 k x1,
  correctness_red ->
  red t1 v1 ->
  red (subst x1 (tr_val v1) k) o ->
  fresh (trm_vars not_used t1) 3 L ->
  red (tr_bind (tr_trm t1) x1 k) o.
Proof.
  introv C R1 R2 Fr. 
  applys red_case. applys* C.
  simpl. applys red_case_1_true.
  applys red_abs_beta. eauto.
Qed.


Hint Constructors cored.

Lemma cored_abs_beta : forall o x t3 v2,
   cored (subst x v2 t3) o ->
   cored (trm_app (trm_abs x t3) v2) o.
Proof.
  introv R. applys cored_app. auto.
  applys cored_app_1. auto. 
  applys cored_app_2 R.
Defined.


Lemma cored_tr_bind_ret : forall t1 v1 k x1,
  correctness_red ->
  correctness_cored ->
  red t1 v1 ->
  diverge (subst x1 (tr_val v1) k) ->
  fresh (trm_vars not_used t1) 3 L ->
  diverge (tr_bind (tr_trm t1) x1 k).
Proof.
  introv C C' R1 R2 Fr. 
  applys cored_case. applys* red_cored.
  simpl. applys cored_case_1_true.
  applys cored_abs_beta. eauto.
Defined.

(** Verification of [tr_cont] *)

Lemma red_tr_cont : forall o2 o t v,
  correctness ->
  red (trm_app t v) o2 ->
  before (add 4 (map cin (tr_out o2))) o ->
  fresh (trm_vars not_used t) 3 L ->
  fresh (val_vars not_used v) 3 L ->
  red (trm_app (tr_cont (tr_trm t)) (tr_val v)) o.
Proof.
  introv C R B3 Frt Frv. inverts R as R1 R2 [L2 L1].
  applys red_abs_beta (add 2 (map cin (tr_out o2))).
  rewrite~ subst_tr_bind. simpl.
  simpl_subst. forwards M: tr_trm_vars Frt. auto.
  rewrite~ (@subst_id not_free). clear M.
  inverts R2 as.
    introv A B. applys red_tr_bind_abort o0; eauto.
     inverts B; inverts L2; done.
    introv R3 R4 [L4 L3]. applys* red_tr_bind_ret (map cin (tr_out o4)).
      inverts L1; done.
      inverts R3. inverts R4 as.
        introv A B. inverts A.
        introv R5 L5. simpl. case_if; tryfalse.
         applys red_abs_beta'. 
         forwards M: fresh_red R1 Frt. simpl in M. 
         rewrite~ <- tr_val_subst. 
         applys* C. applys~ fresh_subst.
         inverts L5; done.
       inverts L4; inverts L2; done.
  destruct o2; inverts B3; done.
Defined.

(** Verification of the transformation [tr_trm].
    Recall that [correctness] is define as:
    [forall t o, red t o -> red (tr_trm t) (map cin (tr_out o))] *)

Lemma tr_trm_correct : correctness.
Proof.
  cofixs IH. introv R Fr. inverts R as; simpls.
  (* case val *)
  unfolds cin. applys* red_inj.
  (* case abs *)
  unfolds cin. applys* red_inj.
  (* case app *)
  introv R1 R2 [L2 L1]. inverts R2 as. 
    introv A B. applys red_tr_bind_abort o2; eauto.
     inverts B; inverts L2; done.
    introv R3 R4 [L4 L3].
     applys* red_tr_bind_ret (add 4 (map cin (tr_out o2)));
       [ |inverts L4; inverts L2; done ].
     rewrite~ subst_tr_bind.
     rewrite (@subst_id not_free); [ | applys~ tr_trm_vars ].
     simpl. simpl_subst. inverts R4 as. 
      introv A B. applys* red_tr_bind_abort o3 o2.
         inverts B; inverts L4; done.
       introv R5 L5.
         applys* red_tr_bind_ret (add 4 (map cin (tr_out o3))).
           inverts L3; done.
           simpl. case_if; tryfalse.
           asserts~ Fr1: (fresh (trm_vars not_used t1) 3 L).
            forwards M1: fresh_red R1 Fr1. simpl in M1.
           asserts~ Fr2: (fresh (trm_vars not_used t2) 3 L).
            forwards M2: fresh_red R3 Fr2. simpl in M2.
            applys red_abs_beta'.
              rewrite <- tr_val_subst.
                applys* IH.
                applys~ fresh_subst.
                auto.
             inverts L5; inverts L4; done.  
           inverts L5; inverts L4; done.
  (* case inj *)
  introv R1 R2 [L2 L1]. inverts R2 as.
    introv A B. applys* red_tr_bind_abort.
      clear_coind. destruct o1; done. inverts B; inverts L2; done.
    applys* red_tr_bind_ret.
      simpl_substs. applys red_inj. applys red_inj_val.
      applys red_inj_1. applys faster_before_max.
      inverts L2. done.
  (* case case *)
  introv R1 R2 [L2 L1].
   asserts~ Fr1: (fresh (trm_vars not_used t1) 3 L).
   asserts~ Fr2: (fresh (trm_vars not_used t2) 3 L). inverts R2 as.
    introv A B. applys red_tr_bind_abort o2; eauto.
     inverts B; inverts L2; done.
    introv R3 L3. applys red_tr_bind_ret
      (map (fun n => (n-5)%nat) (map cin (tr_out o))); eauto;
      [| clear_coind; destruct o; done ].
     sets_eq T: tr_cont. simpl. subst. case_if;tryfalse.
     do 2 rewrite~ subst_tr_cont. 
     do 2 (rewrite (@subst_id not_free); [ | applys~ tr_trm_vars ]).
     applys red_case. applys red_val O. 
     applys red_case_1_true.
     forwards M: fresh_red R1 Fr1. simpl in M.
     applys* red_tr_cont. auto.
     inverts L2. inverts L3. inverts L1. done. inverts L3. done.
    introv R3 L3. applys red_tr_bind_ret 
      (map (fun n => (n-5)%nat) (map cin (tr_out o))); eauto;
      [| clear_coind; destruct o; done ].
     sets_eq T: tr_cont. simpl. subst. simpl_subst.
     do 2 rewrite~ subst_tr_cont.
     do 2 (rewrite (@subst_id not_free); [ | applys~ tr_trm_vars ]).
     applys red_case. applys red_val O. 
     applys red_case_1_false.
     forwards M: fresh_red R1 Fr1. simpl in M.
     applys* red_tr_cont. auto.
     inverts L2. inverts L3. inverts L1. done. inverts L3. done. 
  (* case try *)
  introv R1 R2 [L2 L1]. inverts R2 as.
  inverts L2. inverts L1. applys* red_case. simpl.
   applys red_case_1_true. applys red_abs_beta.
   simpl. case_if; tryfalse. applys red_inj_val.
   auto. auto. done.
  introv R3 L3. applys* red_case. simpl. 
   applys red_case_1_false.
   asserts~ Fr1: (fresh (trm_vars not_used t1) 3 L).
   forwards M: fresh_red R1 Fr1. simpl in M.
   applys* red_tr_cont.
   auto. inverts L3; inverts L2; inverts L1; done.
  inverts L2. applys* red_case.
  (* case raise *)
  introv R1 R2 [L2 L1]. inverts R2 as.
    introv A B. applys* red_tr_bind_abort.
      clear_coind; destruct o1; done. inverts B; inverts L2; done.
    applys* red_tr_bind_ret.
      simpl_substs. applys red_inj_val.
      inverts L2. done.
Qed. 
(* Warning: the check of the guard condition takes about 1 minute *)










=================







Lemma soundness_ind : forall t o T,
  red t o -> typing empty t T -> 
  exists v, o = out_ret v /\ typing empty v T.
Proof.
  introv H. gen o. inductions H; introv R.
  inverts R; auto_false*.
  inverts R; auto_false*. false* binds_empty_inv.
  inverts R; auto_false*.
  inverts R as; auto_false*.
   introv R1 R2. forwards (v1&?&M1): IHtyping1 R1. subst.
   inverts R2 as; auto_false*. 
   introv R2 R3. forwards (v2&?&M2): IHtyping2 R2. subst.
   inverts R3 as; auto_false*.
   introv R4.
   typing_subst


  inverts R.  inverts R; auto_false*.

  inverts R; auto_false*.

  exists* v.
  inverts* M. 
  introv R1 R2. inverts M as M1 M2. 
   forwards~ (v1&E1&V1): H R1 M1. inverts E1. 
   inverts V1. inverts R2 as; auto.
   introv R2 R3. forwards* (v2&E2&V2): H R2.
   inverts E2. inverts~ R3 as.
   introv R3. applys* H R3. apply_empty* typing_subst.
  introv N. false (rm N). destruct~ t. 
    inverts M. false* binds_empty_inv.
Qed.





(*==========================================================*)
(* * Definitions *)



(*==========================================================*)
(* * Alternative approach: modified pretty-big-step *)

Module Alternative.

(************************************************************)
(* ** Semantics *)

(** Ignoring the indices in pretty-big-step semantics *)

Definition out_ret v := out_ter O v.
Coercion out_ret : val >-> out.

(** Evaluation judgment *)

Inductive red : ext -> out -> Prop :=
  | red_val : forall v,
      red v v
  | red_abs : forall x t,
      red (trm_abs x t) (val_clo x t)
  | red_app : forall o1 t1 t2 o2,
      red t1 o1 ->
      red (ext_app_1 o1 t2) o2 ->
      red (trm_app t1 t2) o2
  | red_app_1_abort : forall t2,
      red (ext_app_1 out_div t2) out_div
  | red_app_1 : forall o2 v1 t2 o,
      red t2 o2 ->
      red (ext_app_2 v1 o2) o ->
      red (ext_app_1 v1 t2) o
  | red_app_2_abort : forall v1,
      red (ext_app_2 v1 out_div) out_div
  | red_app_2 : forall x t3 v2 o,
      red (subst x v2 t3) o ->
      red (ext_app_2 (val_clo x t3) v2) o.

Definition reds e v := red e (out_ret v).

(** Co-evaluation judgment: copy-paste of the above
    definition, where [red] is replaced with [cored]
    and where [Inductive] becomes [CoInductive]. *)

CoInductive cored : ext -> out -> Prop :=
  | cored_val : forall v,
      cored v v
  | cored_abs : forall x t,
      cored (trm_abs x t) (val_clo x t)
  | cored_app : forall o1 t1 t2 o2,
      cored t1 o1 ->
      cored (ext_app_1 o1 t2) o2 ->
      cored (trm_app t1 t2) o2
  | cored_app_1_abort : forall t2,
      cored (ext_app_1 out_div t2) out_div
  | cored_app_1 : forall o2 v1 t2 o,
      cored t2 o2 ->
      cored (ext_app_2 v1 o2) o ->
      cored (ext_app_1 v1 t2) o
  | cored_app_2_abort : forall v1,
      cored (ext_app_2 v1 out_div) out_div
  | cored_app_2 : forall x t3 v2 o,
      cored (subst x v2 t3) o ->
      cored (ext_app_2 (val_clo x t3) v2) o.

Definition diverge e := cored e out_div.

Hint Constructors red.

(** Ideally, would be automatically generated by Coq *)

Section RedInd.

(** Copy-paste of the definition of [red], plus a depth counter *)

Inductive redh : nat -> ext -> out -> Prop :=
  | redh_val : forall n v,
      redh (S n) v v
  | redh_abs : forall n x t,
      redh (S n) (trm_abs x t) (val_clo x t)
  | redh_app : forall n o1 t1 t2 o2,
      redh n t1 o1 ->
      redh n (ext_app_1 o1 t2) o2 ->
      redh (S n) (trm_app t1 t2) o2
  | redh_app_1_abort : forall n t2,
      redh (S n) (ext_app_1 out_div t2) out_div
  | redh_app_1 : forall n o2 v1 t2 o,
      redh n t2 o2 ->
      redh n (ext_app_2 v1 o2) o ->
      redh (S n) (ext_app_1 v1 t2) o
  | redh_app_2_abort : forall n v1,
      redh (S n) (ext_app_2 v1 out_div) out_div
  | redh_app_2 : forall n x t3 v2 o,
      redh n (subst x v2 t3) o ->
      redh (S n) (ext_app_2 (val_clo x t3) v2) o.

Hint Constructors redh.
Hint Extern 1 (_ < _) => math.

Lemma redh_lt : forall n n' e o,
  redh n e o -> n < n' -> redh n' e o.
Proof.
  introv H. gen n'. induction H; introv L; 
   (destruct n' as [|n']; [ false; math | auto* ]).
Qed.

Lemma red_redh : forall e o, 
  red e o -> exists n, redh n e o.
Proof.
  hint redh_lt. introv H. induction H; try induct_height.
Qed.

Lemma redh_red : forall n e o,
  redh n e o -> red e o.
Proof. introv H. induction* H. Qed.
 
End RedInd.

(** Lemmas about the irrelevance of the extra index *)

Lemma red_ter_reindex : forall e n n' v,
  red e (out_ter n v) -> red e (out_ter n' v).
Proof.
  introv H. induction H.
Qed.

(** Proof of equivalence *)

(** [red] to [creds] *)

Lemma red_creds : forall e o,
  red e o -> cred e o.
Proof. 
  unfold creds. introv H. lets (n&M): red_redh (rm H).
  exists n. inductions M; auto.
  constructors. applys* IHM1. reflexivity.
  forwards: IHM1.
  eauto 9.
Qed.

(** [creds] to [red] *)

Lemma creds_red : forall t v,
  creds t v -> red t v.
Proof.
  introv (n&R). gen t v. induction n using peano_induction.
  asserts IH: (forall m t v, cred t (out_ter m v) -> m < n -> red t v).
    auto*. clear H.
  introv R. inverts R as; auto.
  introv R1 R2 [L2 L1]. inverts L2. inverts L1.
   inverts R2 as R3 R4 [L4 L3]. inverts L3. inverts L4.
   inverts R4 as R5 L5. inverts L5. constructors*.
Qed.

(** [div] to [cdivs] *)

Lemma cred_red : forall n t v,
  cred t (out_ter n v) -> red t v.
Proof. introv R. apply* reds_red. exists* n. Qed.

Lemma div_cdivs : forall t,
  div t -> cdivs t.
Proof.
  introv R. unfold cdivs. gen t. cofix IH. 
  introv H. inverts H as.
  introv R1. constructors*. 
  introv R1 R2. forwards (n1&M1): red_creds R1. constructors*.
  introv R1 R2 R3. forwards (n1&M1): red_creds R1.
    forwards (n2&M2): red_creds R2. constructors*.
Qed.

(** [cdivs] to [div] *)

Lemma cdivs_div : forall t,
  cdivs t -> div t.
Proof.
  hint red_red. unfolds cdivs. cofix IH.
  introv R. inverts R as R1 R2 [L2 L1].
   inverts L2. inverts R2 as.
     apply* div_app_1.
     introv R3 R4 [L4 L3]. inverts L4. inverts R4 as.
       apply* div_app_2.
       introv R5 L5. inverts L5. apply* div_app_3. 
Qed.

End Alternative.


 


(************************************************************)
(* * Version with a single error rule *)

Inductive xone : ext -> Prop :=
  | xone_val : forall v,
      xone v 
  | xone_abs : forall x t,
      xone (trm_abs x t) 
  | xone_app : forall t1 t2,
      xone (trm_app t1 t2) 
  | xone_app_1_abort : forall t2,
      xone (ext_app_1 out_div t2)
  | xone_app_1 : forall v1 t2,
      xone (ext_app_1 v1 t2) 
  | xone_app_2_abort : forall v1,
      xone (ext_app_2 v1 out_div) 
  | xone_app_2 : forall x t3 v2,
      xone (ext_app_2 (val_clo x t3) v2).

Inductive xred : ext -> out -> Prop :=
  | xred_val : forall v,
      xred v v
  | xred_abs : forall x t,
      xred (trm_abs x t) (val_clo x t)
  | xred_app : forall t1 t2 o1 o2,
      xred t1 o1 ->
      xred (ext_app_1 o1 t2) o2 ->
      xred (trm_app t1 t2) o2
  | xred_app_1_abort : forall t2,
      xred (ext_app_1 out_div t2) out_div
  | xred_app_1 : forall v1 t2 o o2,
      xred t2 o2 ->
      xred (ext_app_2 v1 o2) o ->
      xred (ext_app_1 v1 t2) o
  | xred_app_2_abort : forall v1 ,
      xred (ext_app_2 v1 out_div) out_div
  | xred_app_2 : forall x t3 v2 o,
      xred (subst x v2 t3) o ->
      xred (ext_app_2 (val_clo x t3) v2) o
  | xred_err : forall e,
      ~ xone e ->
      xred e out_err.


(************************************************************)
(* * Proof of equivalence *)

Section Xred.

(** Tactics *)

Hint Constructors red isclo abort.
Hint Constructors xred xone.

Hint Extern 1 (~ xone _) => 
  let H := fresh in intros H; inverts H.

(** [red] to [xred] *)

Lemma red_xred : forall e o, 
  red e o -> xred e o.
Proof.
  introv H. induction* H.
  inverts* H.
  inverts* H.
Qed.

(** [xred] to [red] *)

Hint Extern 1 (xone _) => 
  match goal with H: ~ red _ _ |- _ => 
    false H end.

Lemma xred_red : forall e o, 
  xred e o -> red e o.
Proof.
  introv H. induction* H.
  apply not_not_elim. introv M. applys (rm H). destruct* e.
  destruct* t.
  destruct* o.
  destruct* o. tests (?&?) C: (isclo v); auto*.
Qed.

End Xred.



Implicit Types v : val.
Implicit Types t : trm.
Implicit Types c : ctx.
Implicit Types m : mem.





DEPRECATED STUFF
-----------------




Lemma typing_subst : forall x T U t v,
  typing empty v U ->
  typing (empty & single x U) t T ->
  typing empty (subst x v t) T.
Proof.
  introv Tv Tt.
  apply_empty* typing_subst_ind.
Qed.


(** To add errors: | beh_err : beh. *)
(** To add exceptions: | beh_exn : val -> beh *)  


(** Characterisation of closures (for LATER) *)

Inductive isclo : val -> Prop :=
  | isclo_intro : forall c x t3,
      isclo (val_clo c x t3).

(** For exceptions and errors:
  | abort_err : forall m,
     abort (out_ter m beh_err)
  | abort_exn : forall m v, 
     abort (out_ter m (beh_exn v))
*)

(* FOR LATER, adapt abort rules:
  | red_app_1_abort : forall o1 o t2,
      abort o1 ->
      before o1 o ->
      red (ext_app_1 o1 t2) o
  | red_app_2_abort : forall o2 v1 o,
      abort o2 ->
      before o2 o ->
      red (ext_app_2 v1 o2) o
*)


(* LATER
Definition if_fault (r:res) (k:val->res) : res :=
  match r with
  | res_return (beh_exn v) => k v
  | _ => r
  end.
*)



(** Non-regular behavior (for LATER) *)

Inductive abort : out -> Prop :=
  | abort_div : 
     abort out_div.












(************************************************************)
(* * Alternative The proof in two parts  (less practical) *)

Lemma preserve : forall n t T v,
  red t (out_ter n v) -> typing nil t T -> typing nil v T.
Proof.
  induction n using peano_induction. introv R M.
  inverts R as.
  auto.
  inverts M. constructors*.
  introv R1 R2 [L2 L1]. inverts M as M1 M2. 
   inverts L1. inverts L2. inverts R2 as.
     introv O. inverts O.
     introv R3 R4 [L4 L3]. inverts L3. inverts L4. inverts R4 as.
       introv O. inverts O.
       introv R5 L5. inverts L5. applys~ H R5.
        applys substitution_lemma. 
          applys~ H R3 M2.
          forwards~ M3: H R1 M1. inverts~ M3.
Qed.

Lemma no_error : forall n t T,
  red t (out_ter n res_err) -> typing nil t T -> False.
Proof.
  induction n using peano_induction. introv R M.
  inverts R as.
  inverts M. false. skip. (* ctx_binds nil false *)
  introv R1 R2 [L2 L1]. inverts M as M1 M2. 
   inverts L1. inverts L2. inverts R2 as.
     introv O. applys* H R1.
     introv R3 R4 [L4 L3]. inverts L3. inverts L4. inverts R4 as.
       introv O. applys* H R3.
       introv R5 L5. inverts L5. applys~ H R5.
        applys substitution_lemma.
          applys~ preserve R3 M2.
          lets M3: preserve R1 M1. inverts* M3.
       introv C. forwards V1: preserve R1 M1.
        inverts V1. false C. constructor.
Qed.














(** In full coverage, a term that does not evaluate must diverge *)

Section Not_red_diverge.

Ltac coi_base :=
  match goal with IH: forall _, _ |- _ =>
    apply IH
  end;
  intros (?&?); 
  match goal with N: ~ (exists _,_) |- _  => false N end.

Ltac coi := coi_base; eauto.

Lemma not_red_diverge : forall e,
  ParamFull -> (~ exists o, red e o) -> diverge e.
Proof.
  hint red_cored. introv F. gen e.
  unfold diverge. cofix IH. introv N.
  destruct e.
  destruct t; try solve [ false* N ].
  tests_norew (~ (exists o, red t1 o)).
    constructors*.
    rewrite not_not in C. destruct C as (?&?).
     constructors*. coi. 
  tests_norew (~ (exists o, red t1 o)).
    constructors*.
    rewrite not_not in C. destruct C as (?&?).
     constructors*. coi. 
  tests_norew (~ (exists o, red t o)).
    constructors*.
    rewrite not_not in C. destruct C as (?&?).
     constructors*. coi. 
  rename t into t2. destruct o. 
    tests (isclo v) as V.
      inverts V. tests_norew (~ (exists o, red t2 o)).
        constructors*.
        rewrite not_not in C. destruct C as (?&?).
         constructors*. coi.
      false* N.
    false* N.
    constructors*.
  destruct o. 
    constructors. coi.
    false* N.
    constructors*.
  destruct o. 
    false* N.
    constructors*. coi.
    constructors.
  destruct o. 
    false* N.
    false* N.
    constructors*.
Qed.

End Not_red_diverge.


Lemma red_or_diverge : forall e,
  ParamFull -> (exists o, red e o) \/ diverge e.
Proof. intros. apply classic_right. apply* not_red_diverge. Qed.

(** Statement that a value is a closure *)

Inductive isclo : val -> Prop :=
  | isclo_intro : forall x t, isclo (val_clo x t).

Hint Constructors isclo.








(************************************************************)
(* * Determinacy *)

Inductive equiv : binary out :=
  | equiv_ter : forall n n' b,
      equiv (out_ter n b) (out_ter n' b)
  | equiv_div : 
      equiv out_div out_div.

Hint Constructors equiv.

Inductive ext_equiv : binary ext :=
  | ext_equiv_trm : forall t,
      ext_equiv t t
  | ext_equiv_app_1 : forall o1 o2 t,
      equiv o1 o2 ->
      ext_equiv (ext_app_1 o1 t) (ext_app_1 o2 t)
  | ext_equiv_app_2 : forall o1 o2 v,
      equiv o1 o2 ->
      ext_equiv (ext_app_2 v o1) (ext_app_2 v o2)
  | ext_equiv_try_1 : forall o1 o2 t,
      equiv o1 o2 ->
      ext_equiv (ext_try_1 o1 t) (ext_try_1 o2 t)
  | ext_equiv_raise_1 : forall o1 o2,
      equiv o1 o2 ->
      ext_equiv (ext_raise_1 o1) (ext_raise_1 o2).

Hint Constructors ext_equiv.

Ltac inverts2 E := 
  let H := fresh "TEMP" in inverts E as H; inverts H.

Lemma det_ter_any : forall n e e' b o,
  red e (out_ter n b) -> red e' o -> ext_equiv e e' ->
  exists n', o = out_ter n' b.
Proof.
  induction n using peano_induction.
  asserts IH: (forall e e' b o m,
    red e (out_ter m b) -> red e' o -> ext_equiv e e' ->
    m < n -> exists n', o = out_ter n' b).
    intros. applys* H. clear H.
  introv R S E. inverts R as.
  inverts E. inverts* S.
  inverts E. inverts* S.
  skip.
  introv A B. inverts B. inverts2 E. inverts A;
    inverts S as A' B'; inverts B'; eauto.
  skip.
  introv A B. inverts B. inverts2 E. inverts A;
    inverts S as A' B'; inverts B'; eauto.
  introv R1 L1. inverts L1. inverts2 E. inverts S as.
    introv A B. inverts A.
    introv S1 M1. forwards~ (n1'&N1): IH R1 S1. subst. inverts* M1.
    introv C. false* C.
  introv R1 R2 [L2 L1]. inverts E. inverts S as S1 S2 [M2 M1].
   inverts L1. inverts L2.
   forwards~ (n1'&N1): IH R1 S1. subst.
   forwards~ (n2'&N2): IH R2 S2. subst.
   inverts M2. eauto.
  inverts2 E. inverts* S.
  introv R1 L1. inverts L1. inverts2 E. inverts S as S1 M1.
   forwards~ (n1'&N1): IH R1 S1. subst. inverts* M1.
  inverts2 E. inverts* S.
  introv R1 R2 [L2 L1]. inverts E. inverts S as S1 S2 [M2 M1].
   inverts L1. inverts L2.
   forwards~ (n1'&N1): IH R1 S1. subst.
   forwards~ (n2'&N2): IH R2 S2. subst.
   inverts M2. eauto.
  introv A B. inverts B. inverts2 E. inverts A;
    inverts S as A' B'; inverts B'; eauto.
  inverts2 E. inverts S as.
    introv A B. inverts A.
    eauto.
  inverts E. inverts* S.
  inverts E. inverts* S.
  introv C. inverts2 E. inverts S as.
    introv A B. inverts A.
    false~ C.
    eauto.
Qed.

Lemma equiv_refl : refl equiv.
Proof. intros o. destruct~ o. Qed.
Hint Resolve equiv_refl.

Lemma ext_equiv_refl : refl ext_equiv.
Proof. intros e. destruct~ e. Qed.
Hint Resolve ext_equiv_refl.

Corollary det_ter_ter : forall e n1 n2 b1 b2,
  red e (out_ter n1 b1) -> red e (out_ter n2 b2) -> b1 = b2.
Proof.
  introv R1 R2. forwards~ (?&M): det_ter_any R1 R2. inverts~ M.
Qed.  

Lemma det_ter_div : forall e n b,
  red e (out_ter n b) -> red e out_div -> False.
Proof.
  introv R1 R2. forwards~ M: det_ter_any R1 R2. inverts M. false.
Qed.  

Lemma deterministic : forall e o1 o2,
  red e o1 -> red e o2 -> equiv o1 o2.
Proof.
  introv R1 R2. destruct o1; destruct o2.
  forwards~ (n3&M): det_ter_any R1 R2. inverts~ M.
  forwards: det_ter_div R1 R2. false.
  forwards: det_ter_div R2 R1. false.
  constructor.
Qed.  



Set Implicit Arguments.
Require Import LambdaExn PrettyExn.


(************************************************************)
(* * Interpreter *)

Inductive res :=
  | res_res : val -> res
  | res_exn : val -> res
  | res_unspec : res
  | res_bottom : res.

Implicit Types r : res.

Coercion res_res : val >-> res.

Coercion out_to_res o :=
  match o with
  | out_res v => res_res v
  | out_exn v => res_exn v
  | out_div => res_bottom
  end.

(** Bind-style operators *)

Definition if_success (r:res) (k:val->res) : res :=
  match r with
  | res_res v => k v
  | _ => r
  end.

Definition if_fault (r:res) (k:val->res) : res :=
  match r with
  | res_exn v => k v
  | _ => r
  end.

Definition error :=
  If ParamFull then res_exn val_err else res_unspec.

Definition if_isclo (v:val) (k:var->trm->res) : res :=
  match v with
  | val_clo x t => k x t
  | _ => error
  end.

(** Definition of the interpreter *)

Fixpoint run (n:nat) (t:trm) : res :=
  match n with 
  | O => res_bottom
  | S n' => 
    let run' := run n' in
    match t with
    | trm_val v => v
    | trm_abs x t1 => val_clo x t1
    | trm_var x => error
    | trm_app t1 t2 => 
       if_success (run' t1) (fun v1 =>
         if_isclo v1 (fun x t3 =>
           if_success (run' t2) (fun v2 =>
             if_success (run' (subst x v2 t3)) (fun v3 =>
                res_res v3))))
    | trm_try t1 t2 =>
       if_fault (run' t1) (fun v => run' (trm_app t2 v))
    | trm_raise t1 => 
       if_success (run' t1) (fun v1 => res_exn v1)
    | trm_rand => val_int 0
    end
  end.

(** Definition of "the" result of the interpreter *)

Definition eval t r :=
  exists k, forall n, n > k -> run n t = r.

Definition rundiv t :=
  forall n, run n t = out_div.


(************************************************************)
(* * Properties of evaluation *)


Lemma rundiv_eval_bottom : forall t,
  rundiv t -> eval t res_bottom.
Proof. introv H. exists~ O. Qed.

Lemma out_to_res_inj : forall o1 o2,
  out_to_res o1 = out_to_res o2 -> o1 = o2.
Proof. introv H. destruct o1; destruct o2; inverts~ H. Qed.

(** Monotonicity of [run] *)

Inductive res_le : res -> res -> Prop :=
  | res_le_refl : forall r,
      res_le r r 
  | res_le_bottom : forall r, 
      res_le res_bottom r.

Hint Constructors res_le.

Lemma run_le : forall n n' t, 
  n <= n' -> res_le (run n t) (run n' t).
Proof.
  induction n; introv L.
  simpl. auto.
  destruct n' as [|n']. math.
  asserts IH: (forall t, res_le (run n t) (run n' t)).
    intros. apply IHn. math. 
  clear IHn. simpl. destruct~ t.
  lets L1: IH t1. inverts~ L1. runs_in; auto.
   destruct~ v. simpl.
   lets L2: IH t2. inverts~ L2. runs_in; auto.
   lets L3: IH (subst v v0 t). inverts~ L3.
  lets L1: IH t1. inverts~ L1. runs_in; simple~.
  lets L2: IH t. inverts~ L2. 
Qed.
  
Lemma run_lt_elim : forall n n' t r,
  run n t = r -> n < n' -> r <> res_bottom -> run n' t = r.
Proof.
  introv R L O. forwards M: run_le n n' t. math.
  inverts M; auto_false.
Qed.

(** Properties of [eval] *)

Lemma eval_compare : forall n n' t r1 r2,
  run n t = r1 -> r1 <> res_bottom -> 
  run n' t = r2 -> r2 <> res_bottom ->
  r1 = r2.
Proof.
  introv H1 N1 H2 N2. subst. tests (n <= n').
    forwards~ M: run_le n n' t. inverts~ M. false.
    forwards~ M: run_le n' n t. math. inverts~ M. false.
Qed.

Lemma eval_comp : forall t,
  rundiv t \/ exists r, eval t r.
Proof.
  intros. apply classic_right. unfold rundiv. 
  rew_logic. simpl. intros (m&R). exists (run m t).
  exists m. intros n G. applys~ run_lt_elim.
Qed.

Lemma eval_bottom_rundiv : forall t,
  eval t res_bottom -> rundiv t.
Proof.
  introv (n&R). intros n'. simpl. tests (n' <= n).
    lets~ M: run_le n' (S n) t __. math. 
      sets_eq U: (S n). inverts M as M.
      rewrite M. apply R. math.
      auto.
    apply* R.
Qed.


(************************************************************)
(* * More about the correctness of the interpreter *)

(*

(** another proof that does not rely on completeness *)

Lemma rundiv_or_run : forall t,
  ParamFull -> 
  rundiv t \/ exists n o, run n t = o /\ o <> out_div /\ cored t o.
Proof.
  introv Full. tests (rundiv t) as C. left~. right.
  unfolds rundiv. rew_logic in C. destruct C as [n ?].
  exists n. esplit. splits~.
    apply red_cored. apply* run_red.
Qed.

(* need to use functional induction for this purpose *)
Lemma rundiv_diverge' : forall t,
  ParamFull -> rundiv t -> diverge t.
Proof.
  introv Full. gen t. unfold diverge. cofix IH. introv E.
  lets B: E (S O). destruct t; tryfalse; clear B.
  destruct (rundiv_or_run t1) as [?|(n1&o1&R1&?&?)]. auto.
    constructors*.
    constructors*. destruct o1; tryfalse.
      tests (isclo v) as V.
        destruct V as [x t3].
         destruct (rundiv_or_run t2) as [?|(n2&o2&R2&?&M2)]. auto.
           constructors*.
           applys cored_app_1_clo M2. destruct o2 as [v2| | ]; tryfalse.
             destruct (rundiv_or_run (subst x v2 t3)) as [?|(n3&o3&R3&?&?)]. auto.
               constructors*.
               forwards (n4&?&?): max2 n1 n2. forwards (n&?&?): max2 n3 n4.
                specializes E (S n). simpl in E. 
                 rewrites* (>> run_lt_elim R1) in E. simpl in E.
                 rewrites* (>> run_lt_elim R2) in E. simpl in E.
                 rewrites* (>> run_lt_elim R3) in E. destruct o3; tryfalse.           
             false. forwards (n&?&?): max2 n1 n2.
              specializes E (S n). simpl in E. 
              rewrites* (>> run_lt_elim R1) in E. simpl in E.
              rewrites* (>> run_lt_elim R2) in E.
        false. specializes E (S n1). simpl in E.
         rewrisubst.te R1 in E. simpl in E. destruct v.
         simpl in E. false. false~ V.
      specializes E (S n1). simpl in E.
       rewrite R1 in E. simpl in E. false.
  destruct (rundiv_or_run t1) as [?|(n1&o1&R1&?&?)]. auto.
    constructors*.
    constructors*. destruct o1; tryfalse.
      false. unfolds in E. 
       specializes E (S n1). simpl in E.
       rewrite R1 in E. simpl in E. false.
       (* would need rewriting under binders to factorize proof *)
      constructors. destruct (rundiv_or_run t2) as [?|(n2&o2&R2&?&?)]. auto.
        auto.
        false. forwards (n&?&?): max2 n1 n2.
         specializes E (S n). simpl in E. 
         rewrites* (>> run_lt_elim R1) in E. simpl in E.
         rewrites* (>> run_lt_elim R2) in E.
Qed.

*)


(************************************************************)
(* * Correctness of the interpreter, simple proofs *)

(** correctness, termination case *)

Section RunRed.

Hint Extern 1 (red (ext_trm ?t) _) =>
  match goal with 
   H: (forall _, _), E: run _ t = _ |- _ =>
    applys H E end.

Hint Extern 1 False =>
  match goal with 
   H: (forall _, _), E: run _ _ = _ |- _ =>
    applys H E end.

Lemma run_red_ind : forall n t r, 
  run n t = r -> match r with
    | res_res v => red t (out_res v)
    | res_exn v => red t (out_exn v)
    | res_bottom => True
    | res_unspec => ParamFull -> False
    end.
Proof.
  introv. gen t r.
  induction n using peano_induction. introv R.
  rewrite <- R. clear R. destruct n. 
  simpl. auto.
  specializes H n __. destruct t; simpl.
  auto.
  unfold error. case_if; tryfalse; auto_false.
  auto.
  runs_in; simple*. tests (isclo v) as V.
    inverts V. simpl. runs_in; simple*.
     runs_in; simple*.
    unfold if_isclo. unfold error.
    destruct v; simple*.
      case_if. simple*. auto_false.
      false~ V.
      case_if. simple*. auto_false.
  runs_in; simple*. runs_in; simple*.
  runs_in; simple*.
  auto. 
Qed.

(*
Lemma run_red_ind' : forall n t r, 
  ParamFull ->
  run n t = r -> match r with
    | res_res v => red t (out_res v)
    | res_exn v => red t (out_exn v)
    | res_bottom => True
    | res_unspec => False 
    end.
Proof.
  introv Full. gen t r.
  induction n using peano_induction. introv R.
  rewrite <- R. clear R. destruct n. 
  simpl. auto.
  specializes H n __. destruct t; simpl.
  auto.
  unfold error. case_if; tryfalse. auto.
  auto.
  runs_in; simple*. tests (isclo v) as V.
    inverts V. simpl. runs_in; simple*.
     runs_in; simple*.
    unfold if_isclo. unfold error. case_if; tryfalse.
    destruct v; simple*. false~ V.
  runs_in; simple*. runs_in; simple*.
  runs_in; simple*.
  auto. 
Qed.
*)

Lemma run_red : forall n t o, 
  run n t = o -> o <> out_div -> red t o. 
Proof.
  introv R N. lets~ H: run_red_ind R.
  destruct o; auto_false.
Qed.

Lemma run_stuck : forall n t, 
  ParamFull -> run n t = res_unspec -> False. 
Proof.
  introv F R. lets~ H: run_red_ind R.
Qed.


End RunRed.

(** completeness, termination case *)

Lemma redh_run : forall n n' t o,
  ParamDet -> redh n t o -> n' > n -> run n' t = o.
Proof.
  introv Det. gen n' t o.
  hint redh_lt. induction n using peano_induction.
  asserts IH: (forall m n' t o,
    n' > m -> redh m t o -> m < n -> run n' t = o).
    intros. applys~ H m. clear H.
  introv R L. destruct n as [|n]. inverts R.
  destruct n'. false. math.
  asserts: (n' > n). math. clear L.
  destruct t; simpl.
  inverts~ R.
  inverts R. unfold error. case_if; tryfalse. auto.
  inverts~ R.
  inverts R as R1 R2. rewrites~ (>> IH R1). destruct o1;
    try solve [ inverts R2 as M; inverts~ M ].
   simpl if_success. inverts R2 as.
     introv A. inverts A.
     introv F C. unfold if_isclo,error. case_if; tryfalse.
      destruct~ v. false~ C.
     introv R2 R3. unfold if_isclo at 1.
      rewrites~ (>> IH R2). destruct o2;
       try solve [ inverts R3 as M; inverts~ M ].
      unfold if_success at 1. inverts R3 as.
        introv A. inverts A.
        introv R4. simpl. rewrites* (>> IH (S (S n))). 
         destruct~ o.
  inverts R as R1 R2. rewrites~ (>> IH R1). 
   unfolds. inverts* R2. simpl. apply* IH.
  inverts R as R1 R2. rewrites~ (>> IH R1).
   unfolds. inverts* R2. inverts~ H2.
  inverts R as D. rewrite~ D. 
Qed.

Lemma red_eval : forall t o,
  ParamDet -> red t o -> eval t o. 
Proof.
  introv Det R. forwards (n&M): red_to_redh R.
  exists n. introv H. apply* redh_run.
Qed.

(** correctness, divergence case *)

Lemma rundiv_diverge : forall t,
  ParamFull -> ParamDet ->
  rundiv t -> diverge t.
Proof. 
  introv Full Det H. apply~ not_red_diverge. intros (o&R).
  lets~ (n&M): red_eval R.
  specializes M (S n) __.
  specializes H (S n).
  false (red_trm_not_div' R). 
  forwards~: out_to_res_inj o out_div. congruence.
Qed.

(** completeness, divergence case *)

Lemma diverge_rundiv : forall n t,
  ParamFull -> ParamDet ->
  diverge t -> run n t = out_div.
Proof. 
  introv Full Det.
  unfold diverge. introv D. sets r: (run n t).
  apply not_not_elim. introv M.
  forwards* R: run_red_ind n t r.
  destruct~ r. 
    lets~: red_cored_deterministic R D. false.
    false.
    lets~: red_cored_deterministic R D. false.
Qed.

(** summary *)

Theorem run_iff_red : forall t o,
  ParamDet -> ParamFull ->
  o <> out_div -> (eval t o <-> red t o).
Proof.
  introv Det Full O. iff (n&R) M. 
  specializes R (S n) __. applys* run_red.
  apply* red_eval.
Qed. 

Corollary run_iff_red' : forall t o,
  ParamDet -> ParamFull ->
  ((o <> out_div /\ eval t o) <-> red t o).
Proof.
  introv Det Full. iff [O M] M.
  forwards*: run_iff_red O.
  forwards O: red_trm_not_div' M. split~.
   forwards*: run_iff_red O.
Qed. 

Theorem rundiv_cored : forall t,
  ParamFull -> ParamDet ->
  ((forall n, run n t = out_div) <-> diverge t).
Proof. intros. hint rundiv_diverge, diverge_rundiv. auto*. Qed.



(************************************************************)




(************************************************************)
(* * Proof of equivalence *)


Inductive xabort : out -> Prop :=
  | xabort_div : xabort out_div.

Inductive xone : ext -> Prop :=
  | xone_val : forall v,
      xone v 
  | xone_abs : forall x t,
      xone (trm_abs x t) 
  | xone_app : forall t1 t2,
      xone (trm_app t1 t2) 
  | xone_app_1_abort : forall o1 t2,
      xabort o1 ->
      xone (ext_app_1 o1 t2)
  | xone_app_1 : forall v1 t2,
      xone (ext_app_1 v1 t2) 
  | xone_app_2_abort : forall v1 o2,
      xabort o2 ->
      xone (ext_app_2 v1 o2) 
  | xone_app_2 : forall x t3 v2,
      xone (ext_app_2 (val_clo x t3) v2).

Inductive xred : ext -> out -> Prop :=
  | xred_val : forall v,
      xred v v
  | xred_abs : forall x t,
      xred (trm_abs x t) (val_clo x t)
  | xred_app : forall t1 t2 o1 o2,
      xred t1 o1 ->
      xred (ext_app_1 o1 t2) o2 ->
      xred (trm_app t1 t2) o2
  | xred_app_1_abort : forall o1 t2,
      xabort o1 ->
      xred (ext_app_1 o1 t2) o1
  | xred_app_1 : forall v1 t2 o o2,
      xred t2 o2 ->
      xred (ext_app_2 v1 o2) o ->
      xred (ext_app_1 v1 t2) o
  | xred_app_2_abort : forall v1 o2,
      xabort o2 ->
      xred (ext_app_2 v1 o2) o2
  | xred_app_2 : forall x t3 v2 o,
      xred (subst x v2 t3) o ->
      xred (ext_app_2 (val_clo x t3) v2) o
  | xred_err : forall e,
      ~ xone e ->
      xred e out_err.

Section Xred.

(** Tactics *)

Hint Constructors red isclo abort.
Hint Constructors xred xone xabort.

Lemma xabort_err_inv : 
  xabort out_err -> False.
Proof. introv H; inverts H. Qed.

Lemma xabort_val_inv : forall v, 
  xabort v -> False.
Proof. introv H; inverts H. Qed.

Hint Immediate xabort_err_inv xabort_val_inv.
Hint Extern 1 (~ xone _) => 
  let H := fresh in intros H; inverts H.

(** [red] to [xred] *)

Lemma red_xred : forall e o, 
  red e o -> xred e o.
Proof.
  introv H. induction* H.
  inverts* H.
  inverts* H.
Qed.

(** [xred] to [red] *)

Hint Extern 1 (xone _) => 
  match goal with H: ~ red _ _ |- _ => 
    false H end.

Lemma xred_red : forall e o, 
  xred e o -> red e o.
Proof.
  introv H. induction* H.
  inverts* H.
  inverts* H.
  apply not_not_elim. introv M. applys (rm H). destruct* e.
  destruct* t.
  destruct* o.
  destruct* o. tests (isclo v) as (?&?) C; auto*.
Qed.

End Xred.




(************************************************************)
(* * Bonus *)

Definition Le o (n n':nat) :=
  match o with
  | out_div => True
  | _ => n <= n'
  end.

Lemma red_Le : forall n n' e o,
  red n e o -> Le o n n' -> red n' e o.
Proof. 
  intros. destruct o. apply* red_le. apply* red_div_n.
Qed.





Set Implicit Arguments.
Require Import Lambda.


(************************************************************)
(* * Definitions *)

(** Outcome of an evaluation *)

Inductive res :=
  | res_ret : val -> res
  | res_err : res.

Coercion res_ret : val >-> res.

Inductive out :=
  | out_ter : nat -> res -> out
  | out_div : out.

Implicit Types o : out.
Implicit Types n : nat.

(** Partial order on the outcomes *)

Inductive faster : binary out :=
  | faster_ter : forall n n' r r',
      n < n' ->
      faster (out_ter n r) (out_ter n' r')
  | faster_div : forall o,
      faster o out_div.

Inductive before : binary out :=
  | before_ter : forall n n' r,
      n < n' ->
      before (out_ter n r) (out_ter n' r)
  | before_div : 
      before out_div out_div.

(** Grammar of extended terms *)

Inductive ext : Type :=
  | ext_trm : trm -> ext
  | ext_app_1 : out -> trm -> ext
  | ext_app_2 : val -> out -> ext.

Coercion ext_trm : trm >-> ext.
Implicit Types v : val.
Implicit Types t : trm.
Implicit Types e : ext.

(** Non regular behaviors *)

Inductive abort : out -> Prop :=
  | abort_div : 
     abort out_div
  | abort_err : forall n,
     abort (out_ter n res_err).

(** Characterisation of closures *)

Inductive isclo : val -> Prop :=
  | isclo_intro : forall x t3, isclo (val_clo x t3).

(** Optimization for automation:
    instead of writing two premises
    [faster o1 o -> before o2 o -> ..]
    we use a combined premise as follows. *)

Definition faster_before o1 o2 o :=
  before o2 o /\ faster o1 o.

(** Reduction *)

CoInductive red : ext -> out -> Prop :=
  | red_var : forall n x,
      red (trm_var x) (out_ter n res_err)
  | red_val : forall n v,
      red v (out_ter n v)
  | red_abs : forall n x t,
      red (trm_abs x t) (out_ter n (val_clo x t))
  | red_app : forall o t1 t2 o1 o2,
      red t1 o1 -> 
      red (ext_app_1 o1 t2) o2 -> 
      faster_before o1 o2 o ->
      red (trm_app t1 t2) o
  | red_app_1_abort : forall o1 t2 o,
      abort o1 -> before o1 o ->
      red (ext_app_1 o1 t2) o
  | red_app_1 : forall o n v1 t2 o2 o3,
      red t2 o2 -> 
      red (ext_app_2 v1 o2) o3 -> 
      faster_before o2 o3 o ->
      red (ext_app_1 (out_ter n v1) t2) o
  | red_app_2_abort : forall o1 o v1,
      abort o1 -> before o1 o ->
      red (ext_app_2 v1 o1) o
  | red_app_2 : forall o n x t3 v2 o3,
      red (subst x v2 t3) o3 -> 
      before o3 o ->
      red (ext_app_2 (val_clo x t3) (out_ter n v2)) o
  | red_app_2_err : forall v1 n n' v2,
      ~ isclo v1 ->
      red (ext_app_2 v1 (out_ter n v2)) (out_ter n' res_err).

Definition reds e v := exists n, red e (out_ter n v).

Definition divs e := red e out_div.

Definition stuck e := exists n, red e (out_ter n res_err).


(************************************************************)
(* * Facts *)

Hint Constructors abort isclo red faster before.
Hint Extern 1 (_ < _) => math.
Hint Extern 1 (_ <> _) => congruence.
Hint Extern 1 ((_ < _)%nat) => math.

Lemma faster_before_max : forall n1 n2 b1 b2 ,
  faster_before (out_ter n1 b1) (out_ter n2 b2) (out_ter (S (max n1 n2)) b2).
Proof. intros. forwards [[? ?]|[? ?]]: max_cases n1 n2. split~. split~. Qed.

Lemma faster_le_l : forall o n n' b,
  faster o (out_ter n b) -> n <= n' -> faster o (out_ter n' b).
Proof. introv O L. inverts* O. Qed.

Lemma before_le_l : forall o n n' b,
  before o (out_ter n b) -> n <= n' -> before o (out_ter n' b).
Proof. introv O L. inverts* O. Qed.

Hint Resolve faster_le_l before_le_l.

Lemma faster_before_le_l : forall o1 o2 n n' b,
  faster_before o1 o2 (out_ter n b) -> n <= n' -> faster_before o1 o2 (out_ter n' b).
Proof. unfold faster_before. introv [O1 O2] L. split*. Qed.

Hint Resolve faster_before_le_l.

Lemma red_le : forall n n' e b,
  red e (out_ter n b) -> n <= n' -> red e (out_ter n' b).
Proof.
  cofix IH. introv R L. inverts R; try solve [ constructors* ].
  applys* red_app_1.
  applys* red_app_2.
  applys* red_app_2_err.
Qed.

Lemma faster_succ : forall n b,
  faster (out_ter n b) (out_ter (S n) b).
Proof. intros. auto. Qed.

Lemma before_succ : forall n b,
  before (out_ter n b) (out_ter (S n) b).
Proof. intros. auto. Qed.

Ltac max_resolve :=
  simpl; match goal with |- context [max ?n1 ?n2] =>
    let e := fresh "m" in
    destruct (max_cases n1 n2) as [[? ?]|[? ?]];
    set (e := max n1 n2) in *; clearbody e end.

Hint Extern 1 (before _ _) => apply before_succ.
Hint Extern 1 (faster _ _) => apply faster_succ.
Hint Resolve faster_before_max.
Hint Extern 1 (before _ _) => max_resolve; constructor.
Hint Extern 1 (faster_before _ _ _) => apply faster_before_max.
Hint Extern 3 (faster_before _ _ _) => split.


(************************************************************)
(* * Full-coverage property *)

Definition terminates e := exists n b, red e (out_ter n b).

Ltac esplits := 
  esplit;
  repeat (match goal with |- exists _, _ => esplit end).

Lemma red_not_terminates_div : forall e,
  ~ terminates e -> red e out_div.
Proof.
  cofix IH. introv N. destruct e.
  destruct t; try solve [ false N; exists O __; auto ].
  tests (terminates t1) as C.  
    destruct C as (n1&b1&R1).
     tests (terminates (ext_app_1 (out_ter n1 b1) t2)) as C'.
       destruct C' as (n2&b2&R2). false N. esplits. applys* red_app.
       forwards: IH C'. applys* red_app.
     applys* red_app.
  destruct o.
    destruct r.
      tests (terminates t) as C.  
        destruct C as (n1&b1&R1).
         tests (terminates (ext_app_2 v (out_ter n1 b1))) as C'.
           destruct C' as (n2&b2&R2). false N. esplits. applys* red_app_1.
           forwards: IH C'. applys* red_app_1.
        applys* red_app_1. 
      false N. esplits. applys~ red_app_1_abort.
    constructors~.
  destruct o.
    destruct r.
      tests (isclo v) as C.
        inverts C as (?&?&?).
         tests (terminates (subst x v0 t3)) as C'.
           destruct C' as (?&?&?). false N. esplits. applys* red_app_2.
           forwards: IH C'. applys* red_app_2.
        false N. exists O __. applys~ red_app_2_err.
      false N. esplits. applys~ red_app_2_abort.
    constructors~.
Qed.

Lemma red_full : forall e, exists o, red e o.
Proof.
  intros. tests_norew (exists n b, red e (out_ter n b)).
  destruct C as (n&b&?). eauto.
  exists out_div. apply* red_not_terminates_div.
Qed.


(************************************************************)
(* * Typing *)

CoInductive typ :=
  | typ_int : typ
  | typ_arrow : typ -> typ -> typ.

Axiom ctx_binds : forall A, ctx A -> var -> A -> Prop.

Inductive typing : ctx typ -> trm -> typ -> Prop :=
  | typing_int : forall E k,
      typing E (val_int k) typ_int
  | typing_clo : forall x U T t1,
      typing ((x,U)::nil) t1 T ->
      typing nil (val_clo x t1) (typ_arrow U T)
  | typing_var : forall E x T,
      ctx_binds E x T ->
      typing E (trm_var x) T
  | typing_abs : forall x E U T t1,
      typing ((x,U)::E) t1 T ->
      typing E (trm_abs x t1) (typ_arrow U T)
  | typing_app : forall S T E t1 t2,
      typing E t1 (typ_arrow S T) -> 
      typing E t2 S ->
      typing E (trm_app t1 t2) T.

Axiom substitution_lemma : forall x T U t v,
  typing nil v U ->
  typing ((x,U)::nil) t T ->
  typing nil (subst x v t) T.
(* not done here to avoid binder issues *)


(************************************************************)
(* * Proof of soundness *)

(** The following statement for the induction is equivalent to 
    [red t (out_ter n b) -> typing nil t T -> 
       exists v, b = res_ret v /\ typing nil v T.] *)

Lemma soundness_ind : forall n t T b,
  red t (out_ter n b) -> typing nil t T -> 
  match b with
  | res_ret v => typing nil v T
  | res_err => False
  end.
Proof.
  induction n using peano_induction. introv R M.
  inverts R as.
  inverts M. false. skip. (* ctx_binds nil false *)
  auto.
  inverts M. constructors*.
  introv R1 R2 [L2 L1]. inverts M as M1 M2. 
   inverts L1. inverts L2. inverts R2 as.
     introv O L3. inverts L3. inverts O. applys* H R1.
     introv R3 R4 [L4 L3]. inverts L3. inverts L4. inverts R4 as.
       introv O L3. inverts L3. inverts O. applys* H R3.
       introv R5 L5. inverts L5. applys~ H R5.
        applys substitution_lemma.
          applys~ H R3 M2.
          lets~ M3: H R1 M1. inverts* M3.
       introv C. forwards~ V1: H R1 M1.
        inverts V1. false~ C. 
Qed.

(** Well-typed terms don't get stuck. Recall that
    [stuck e := exists n, red e (out_ter n res_err)]. *)

Lemma soundness : forall t T, 
  typing nil t T -> ~ stuck t.
Proof. introv M (n&R). false (soundness_ind R M). Qed.



(************************************************************)
(* * Alternative proof, on a slightly different judgment *)

Lemma soundness_ind' : forall n t T b,
  red t (out_ter n b) -> typing nil t T -> 
  exists v, b = res_ret v /\ typing nil v T.
Proof.
  induction n using peano_induction. introv R M.
  inverts R as.
  inverts M. false. skip. (* ctx_binds nil false *)
  eauto.
  inverts M. esplit. split~. constructors*.
  introv R1 R2 [L2 L1]. inverts M as M1 M2. 
   inverts L1. inverts L2. inverts R2 as.
     introv O. inverts O. forwards~ (?&?&?): H R1 M1. false.
     introv R3 R4 [L4 L3]. inverts L3. inverts L4.
      forwards~ (?&?&?): H R3 M2. inverts R4 as.
       introv O. inverts O. false.
       inverts TEMP. introv R5 L5. inverts L5. forwards~ (?&?&?): H R5.
         applys substitution_lemma.
           eauto.
           forwards~ (?&E&F): H R1 M1. inverts E. inverts* F.
         eauto.
       introv C. forwards~ (?&E&F): H R1 M1. inverts E.
        inverts F. false~ C. 
Qed.






(** --old 

Hint Constructors abort red faster before.
Hint Extern 1 (_ < _) => math.
Hint Extern 1 (_ <= _) => math.
Hint Extern 1 (_ <> _) => congruence.
Hint Extern 1 ((_ < _)%nat) => math.

Lemma faster_before_max : forall n1 n2 v1 v2,
  faster_before (out_ter n1 v1) (out_ter n2 v2) (out_ter (S (max n1 n2)) v2).
Proof. intros. forwards [[? ?]|[? ?]]: max_cases n1 n2. split~. split~. Qed.

Lemma faster_le_l : forall o n n' b,
  faster o (out_ter n b) -> n <= n' -> faster o (out_ter n' b).
Proof. introv O L. inverts* O. Qed.

Lemma before_le_l : forall o n n' b,
  before o (out_ter n b) -> n <= n' -> before o (out_ter n' b).
Proof. introv O L. inverts* O. Qed.

Hint Resolve faster_le_l before_le_l.

Lemma faster_before_le_l : forall o1 o2 n n' b,
  faster_before o1 o2 (out_ter n b) -> n <= n' -> faster_before o1 o2 (out_ter n' b).
Proof. unfold faster_before. introv [O1 O2] L. split*. Qed.

Hint Resolve faster_before_le_l.

Lemma red_le : forall n n' e b,
  red e (out_ter n b) -> n <= n' -> red e (out_ter n' b).
Proof.
  cofix IH. introv R L. inverts R; try solve [constructors*].
  applys* red_app_1. applys* red_app_2. applys* red_raise_1.
Qed.

Lemma faster_succ : forall n b,
  faster (out_ter n b) (out_ter (S n) b).
Proof. intros. auto. Qed.

Lemma before_succ : forall n b,
  before (out_ter n b) (out_ter (S n) b).
Proof. intros. auto. Qed.

Ltac max_resolve :=
  simpl; match goal with |- context [max ?n1 ?n2] =>
    let e := fresh "m" in
    destruct (max_cases n1 n2) as [[? ?]|[? ?]];
    set (e := max n1 n2) in *; clearbody e end.

Hint Extern 1 (before _ _) => apply before_succ.
Hint Extern 1 (faster _ _) => apply faster_succ.
Hint Resolve faster_before_max.
Hint Extern 1 (before _ _) => max_resolve; constructor.
Hint Extern 1 (faster_before _ _ _) => apply faster_before_max.
Hint Extern 3 (faster_before _ _ _) => split.


*)



Lemma if_success_result' : forall n r o1 r1 o k,
  result n r1 o1 -> 
  if_success r1 k = r ->
  faster o1 o ->
  (match o1 with
   | out_ter _ (beh_ret v1) => result (S n) (k v1) o  
   | out_ter _ _ => before o1 o
   | out_div => o = out_div
   end) ->
  result (S n) r o.
Proof.
  introv R I F M. unfold result in R. unfolds if_success.
  destruct o1.
  destruct R as [E|[E L]].
    subst r1. destruct b.
      subst~.
      inverts M. unfolds. left~.
      inverts M. unfolds. left~.
    subst r1 r. unfolds. destruct~ o.
      right. split~. inverts F. math.
  subst o r1 r. unfolds. auto.
Qed.

Lemma if_fault_result' : forall n r o1 r1 o k,
  result n r1 o1 -> 
  if_fault r1 k = r ->
  faster o1 o ->
  (match o1 with
   | out_ter _ (beh_exn v1) => result (S n) (k v1) o  
   | out_ter _ _ => before o1 o
   | out_div => o = out_div
   end) ->
  result (S n) r o.
Proof.
  introv R I F M. unfold result in R. unfolds if_success.
  destruct o1.
  destruct R as [E|[E L]].
    subst r1. destruct b.
      inverts M. unfolds. left~.
      subst~.
      inverts M. unfolds. left~.
    subst r1 r. unfolds. destruct~ o.
      right. split~. inverts F. math.
  subst o r1 r. unfolds. auto.
Qed.


(* ---not used
Lemma before_trans : forall o2 o1 o3 (d1 d2 d3:nat), 
  beforeby d1 o1 o2 -> beforeby d2 o2 o3 -> d3 < (d1+d2)%nat ->
  beforeby d3 o1 o3.
Proof.
  introv L1 L2 D. inverts L1; inverts L2.
  constructor. math.
  constructor. 
Qed.

Lemma faster_before_join : forall o1 o2,
  (o1 = out_div -> o2 = out_div) ->
  faster_before o1 o2 (match o2 with 
    | out_ter n2 r2 => match o1 with
        | out_ter n1 r1 => out_ter (S (max n1 n2)) r2
        | out_div => out_div
        end
    | out_div => out_div end
    ).
Proof.
  introv E. destruct o1; destruct o2.
  applys~ faster_before_max.
  auto. split~. false E. auto. auto.
Qed.
*)



(*--old

Hint Constructors abort red faster before.
Hint Extern 1 (_ < _) => math.
Hint Extern 1 (_ > _) => math.
Hint Extern 1 (_ <> _) => congruence.
Hint Extern 1 ((_ < _)%nat) => math.


Lemma faster_before_max : forall n1 n2 r1 r2,
  faster_before (out_ter n1 r1) (out_ter n2 r2) (out_ter (S (max n1 n2)) r2).
Proof. intros. forwards [[? ?]|[? ?]]: max_cases n1 n2. split~. split~. Qed.


Lemma faster_le_l : forall o n n' v,
  faster o (out_ter n v) -> n <= n' -> faster o (out_ter n' v).
Proof. introv O L. inverts* O. Qed.

Lemma before_le_l : forall o n n' v,
  before o (out_ter n v) -> n <= n' -> before o (out_ter n' v).
Proof. introv O L. inverts* O. Qed.

Hint Resolve faster_le_l before_le_l.

Lemma faster_before_le_l : forall o1 o2 n n' v,
  faster_before o1 o2 (out_ter n v) -> n <= n' -> faster_before o1 o2 (out_ter n' v).
Proof. unfold faster_before. introv [O1 O2] L. split*. Qed.

Hint Resolve faster_before_le_l.

Lemma red_le : forall n n' e r,
  red e (out_ter n r) -> n <= n' -> red e (out_ter n' r).
Proof. cofix IH. introv R L. Admitted.


Lemma faster_succ : forall n r,
  faster (out_ter n r) (out_ter (S n) r).
Proof. intros. auto. Qed.

Lemma before_succ : forall n r,
  before (out_ter n r) (out_ter (S n) r).
Proof. intros. auto. Qed.


Hint Extern 1 (before _ _) => apply before_succ.
Hint Extern 1 (faster _ _) => apply faster_succ.
Hint Resolve faster_before_max.


Ltac max_resolve :=
  simpl; match goal with |- context [max ?n1 ?n2] =>
    let e := fresh "m" in
    destruct (max_cases n1 n2) as [[? ?]|[? ?]];
    set (e := max n1 n2) in *; clearbody e end.

Hint Extern 1 (before _ _) => max_resolve; constructor.
Hint Extern 1 (faster_before _ _ _) => apply faster_before_max.
Hint Extern 3 (faster_before _ _ _) => split.


*)



Lemma faster_succ' : forall o,
  faster o (map S o).
Proof. intros. destruct o; simple~. Qed.

Lemma faster_add : forall o n,
  n > O ->
  faster o (add n o).
Proof. intros. destruct o; simple~. Qed.


Lemma idprop : 
  (forall t, bigdiv t -> red t out_div) ->
  forall t1 t2,
  bigdiv t1 -> red (trm_app t1 t2) out_div.
Proof.
  introv IH H. constructors*.
Defined.

Lemma bigdiv_divs : forall t,
  bigdiv t -> divs t.
Proof.
  introv R. unfold divs. gen t. cofix IH. 
  introv H. inverts H as.
  introv R1. apply idprop. apply IH. auto.
  introv R1 R2. forwards (n1&M1): bigred_reds R1. constructors*.
  introv R1 R2 R3. forwards (n1&M1): bigred_reds R1.
    forwards (n2&M2): bigred_reds R2. constructors*.
Qed.






Definition hide (P G:Prop) := { p:P | G = G }.
Definition hide_intro (P G:Prop) (H:P) : hide P G :=
  exist _ H (refl_equal G).
Definition hide_elim (P G:Prop) (H:hide P G) : P :=
  match H with exist p _ => p end.

Lemma hide_use (P G R:Prop) (H:hide P G) (M:P -> R) : R.
lets: hide_elim H. auto.
Defined.

Ltac testa :=
  match goal with 
 (* | H: hide _ ?G |- ?G => fail 1*)
  | H: hide _ _ |- _ => let M := fresh in lets M: (hide_elim H); instantiate; simpl in M; clear H
  end.

Hint Extern 1 (red _ _) => hide_use.

Lemma bigdiv_divs : forall t, bigdiv t -> red t out_div.
Proof.
  cofix IH.
  introv H. inverts H as.
  introv R1.
  match goal with |- ?G => 
    lets IH': (hide_intro G IH) end. clear IH.
applys red_app. eapply hide_use; eauto. eauto.
 eapply hide_elim. 
  match goal with 
  | H: hide _ _ |- _ =>  lets: (hide_elim H)
  end.
info
auto. simpl 

 auto. testa. match goal with |- red _ _ => pose true end. auto.
  match goal with 
  | H: hide _ ?G |- ?G => fail 1
  | H: hide _ _ |- _ => lets: (hide_elim H); clear H
  end.

eauto.

  match goal with 
  | H: hide _ ?G |- ?G => fail 2
  | H: hide _ _ |- _ => lets: (hide_elim H); clear H
  end; auto.
  match goal with 
  | H: hide _ ?G |- ?G => fail 2
  | H: hide _ _ |- _ => lets: (hide_elim H); clear H
  end. auto.

  match goal with 
  | H: hide _ ?G |- ?G => fail 2
  | H: hide _ _ |- _ => lets: (hide_elim H); clear H
  end. auto.
    auto*.
  lets: hide_elim IH'. constructors*.
  introv R1 R2. forwards (n1&M1): bigred_reds R1. constructors*.
  introv R1 R2 R3. forwards (n1&M1): bigred_reds R1.
    forwards (n2&M2): bigred_reds R2. constructors*.
Qed.



Lemma red_tr_bind : forall o t1' o1 o1' x k f,
  red t1' o1' ->
  o1' = map f (tr_out o1) ->
  faster o1' o ->
  (match o1 with
    | out_ter _ (res_ret v1) =>
        exists o2,
        red (subst x (tr_val v1) k) o2 /\
        before (add 4%nat o2) o
    | out_ter _ (res_exn v1) =>
        before (add 5%nat o1') o
    | out_div => o = out_div 
    end) ->
  red (tr_bind t1' x k) o.
Proof.




  (* case case 
  introv R1 R2 [L2 L1].
  skip_rewrite (o = out_div).   skip_rewrite (o1 = out_div) in R1.
   applys red_tr_bind'. applys IH. applys R1. reflexivity. auto. auto. auto.
Guarded.
  inverts L2.
    skip.
    inverts R2 as.
    introv A B. inverts B. simpl.
   applys red_tr_bind'. applys IH. applys R1. reflexivity. auto.
   skip.   skip. skip. skip.
Guarded.
admit.
admit.

(*
  introv R1 R2 [L2 L1].
   applys red_tr_bind. applys IH. applys R1. reflexivity.
  applys~ faster_map; applys~ faster_tr_out.
  destruct o1 as [n1 [v1|v1]|].

    exists (map cin (tr_out o2)). split.
      sets_eq u2: (tr_cont (tr_trm t2)).
       sets_eq u3: (tr_cont (tr_trm t3)). 
       simpl. case_if; tryfalse. do 2 rewrite subst_id. (* bound vars *)
       subst u2 u3.
       inverts R2 as.
         introv A B. inverts A.
         introv R3 L3. simpl. applys red_case. applys red_val O.
          applys red_case_1_true (add 5 (map cin (tr_out o1))). 
          inverts R3 as R4 R5 [L5 L4]. lets M2: IH R4. 
          applys* red_tr_cont o1.
          destruct o1; unfold cin; simpls; auto.
          applys before_succ'.
          destruct o1 as [? [?|?]|]; inverts L3; inverts L2;
           inverts L1; unfold cin; simpl; auto.
         skip.
      inverts L2; simpl; unfold cin; auto.

    inverts R2 as A B. inverts A. inverts B.
     inverts L2. inverts L1. unfold cin. simpl. auto.
    inverts L1. auto.
*)
*)
  (* case try *)
  introv R1 R2 [L2 L1]. forwards M1: IH R1.
  destruct o1 as [n1 [v1|v1]|]; simpls. 
  inverts R2. inverts L2. inverts L1.
   applys red_case M1. applys red_case_1_true.
   applys red_abs_beta. simpl_subst. applys red_inj_val.
   applys before_succ'. applys before_succ'.
   unfold cin. simpl. auto.
  inverts R2 as R3 L3. applys red_case (add 5 (map cin (tr_out o2))) M1;
    [|unfold cin; auto].
   applys red_case_1_false (add 4 (map cin (tr_out o2))); [|unfold cin; auto].
   applys red_abs_beta (add 5 (map cin (tr_out o1))).
   simpl_subst; [skip|]. rewrite subst_id. case_if; tryfalse. (* bound var *)
   clear H H0. inverts R3 as R4 R5 [L5 L4]. 
   forwards M2: IH R4. applys red_tr_bind. eauto. eauto.
    inverts L4; simpls; unfold cin; auto.
    destruct o0 as [n2 [v2|v2]|]; simpls.
      case_if; tryfalse. clear H. exists ( (map cin (tr_out o1))).
       split. inverts R5 as.
        introv A B. inverts B. inverts A.
        introv R6 R7 [L7 L6]. inverts R6. inverts R7 as.
          introv A B. inverts A.
          introv R8 L8. simpl. applys red_abs_beta'.
          rewrite <- tr_val_subst. applys* IH.
        inverts L8; inverts L7; inverts L5; unfold cin; simpl; auto.
        destruct o1; simpl; auto.
      inverts R5 as A B. inverts B. inverts L5. simpl. unfold cin. auto.
      inverts L4. auto.
    inverts L3; simpl; unfold cin; auto.
    inverts L2. inverts L1. simpl. unfold cin. auto.
    simpl. auto.
    inverts L2; inverts L1; simpl; unfold cin; auto.
  inverts R2. inverts L2. applys red_case M1.
    applys~ red_case_1_abort. simple~. 






Qed.















Lemma red_tr_bind' : forall o t1' o1 o1' x k f,
  red t1' o1' ->
  o1' = map f (tr_out o1) ->
  faster o1' o ->
  (* (match o with out_div => o1 = out_div | _ => False end) ->*)
  o = out_div -> o1 = out_div ->
  red (tr_bind t1' x k) o.
Proof.
  introv R1 E1 F1 M M'. destruct o. false.
  subst o1 o1'. applys* red_case.
Defined.
(*
*)


Lemma red_tr_bind : forall o t1' o1 o1' x k f,
  red t1' o1' ->
  o1' = map f (tr_out o1) ->
  faster o1' o ->
  (match o1 with
    | out_ter _ (res_ret v1) =>
        exists o2,
        red (subst x (tr_val v1) k) o2 /\
        before (add 4%nat o2) o
    | out_ter _ (res_exn v1) =>
        before (add 5%nat o1') o
    | out_div => o = out_div 
    end) ->
  red (tr_bind t1' x k) o.
Proof.
  introv R1 E1 F1 M. destruct o1 as [n1 [v1|v1]|]; simpls.
  destruct M as (o2&R2&L2). subst o1'.
   applys red_case R1. applys red_case_1_true.
   applys red_abs_beta. eauto. auto. auto.
   destruct o2; inverts L2; simple~.
  subst o1'. applys red_case R1. applys red_case_1_false.
   applys red_abs_beta. unfold tr_exn. simpl_subst.
   applys red_inj_val. auto. auto. inverts M. inverts F1.
   unfolds cin. simpl. auto.
  subst o o1'. applys* red_case.
Defined.

(*
Lemma red_tr_bind : forall o t1' o1 o1' x k f,
  red t1' o1' ->
  o1' = map f (tr_out o1) ->
  faster o1' o ->
  (match o1 with
    | out_ter _ (res_ret v1) =>
        exists o2,
        red (subst x (tr_val v1) k) o2 /\
        before (add 4%nat o2) o
    | out_ter _ (res_exn v1) =>
        before (add 5%nat o1') o
    | out_div => o = out_div 
    end) ->
  red (tr_bind t1' x k) o.
Proof.
  introv R1 E1 F1 M. subst o1'. inverts R1 as.
destruct o1 as [n1 [v1|v1]|]; simpls.
skip.
skip.
skip.
  destruct M as (o2&R2&L2). subst o1'.
   applys red_case R1. applys red_case_1_true.
   applys red_abs_beta. eauto. auto. auto.
   destruct o2; inverts L2; simple~.
  subst o1'. applys red_case R1. applys red_case_1_false.
   applys red_abs_beta. unfold tr_exn. simpl_subst.
   applys red_inj_val. auto. auto. inverts M. inverts F1.
   unfolds cin. simpl. auto.
  subst o o1'. applys* red_case.

Defined.
*)


(*
Proof.
  introv R1 E1 F1 M. destruct o1 as [n1 [v1|v1]|]; simpls.
  destruct M as (o2&R2&L2). subst o1'.
   applys red_case R1. applys red_case_1_true.
   applys red_abs_beta. eauto. auto. auto.
   destruct o2; inverts L2; simple~.
  subst o1'. applys red_case R1. applys red_case_1_false.
   applys red_abs_beta. unfold tr_exn. simpl_subst.
   applys red_inj_val. auto. auto. inverts M. inverts F1.
   unfolds cin. simpl. auto.
  subst o o1'. applys* red_case.
Defined.
*)


(*
Lemma red_tr_cont : forall o3 o t1' o1 o2 v2,
  correctness ->
  red t1' (map cin (tr_out o1)) ->
  faster o1 o3 ->
  red (ext_app_1 o1 v2) o2 -> 
  before o2 o3 -> 
  before (add 4 (map cin (tr_out o3))) o ->
  red (trm_app (tr_cont t1') (tr_val v2)) o.
Proof.
  introv IH R1 L1 R2 L2 L3. subst. unfold tr_cont.
  applys red_abs_beta (add 2 (map cin (tr_out o3))).
  simpl_subst; [skip|]. (* bound var *) case_if; tryfalse.
  rewrite subst_id.
  applys red_tr_bind. eauto. eauto.
  destruct o1; inverts L1; simpls; unfold cin; auto.
  inverts R2 as.
    introv A B. inverts A.
      inverts B. inverts L2. simpl. unfold cin. auto.
      inverts B. inverts L2. auto.
    introv R4 R5 [L5 L4]. inverts R4. inverts R5 as.
      introv A B. inverts A.
      introv R6 L6. exists (add 3 (map cin (tr_out o4))). split.
        simpl_subst. applys red_abs_beta'. 
        rewrite <- tr_val_subst. applys IH R6. 
        inverts L6; simpl; unfold cin; auto.
      inverts L5; inverts L2; simpl; unfold cin; auto.
  destruct o3; simpls; inverts L3; auto.
Defined.
*)
 
         
Lemma red_tr_cont : forall o3 o t1' o1 o2 v2,
  correctness ->
  red t1' (map cin (tr_out o1)) ->
  faster o1 o3 ->
  red (ext_app_1 o1 v2) o2 -> 
  before o2 o3 -> 
  before (add 4 (map cin (tr_out o3))) o ->
  red (trm_app (tr_cont t1') (tr_val v2)) o.
Proof.
  introv IH R1 L1 R2 L2 L3. subst. unfold tr_cont.
  applys red_abs_beta (add 2 (map cin (tr_out o3))).
  simpl_subst; [skip|]. (* bound var *) case_if; tryfalse.
  rewrite subst_id.
  applys red_tr_bind. eauto. eauto.
  destruct o1; inverts L1; simpls; unfold cin; auto.
  inverts R2 as.
    introv A B. inverts A.
      inverts B. inverts L2. simpl. unfold cin. auto.
      inverts B. inverts L2. auto.
    introv R4 R5 [L5 L4]. inverts R4. inverts R5 as.
      introv A B. inverts A.
      introv R6 L6. exists (add 3 (map cin (tr_out o4))). split.
        simpl_subst. applys red_abs_beta'. 
        rewrite <- tr_val_subst. applys IH R6. 
        inverts L6; simpl; unfold cin; auto.
      inverts L5; inverts L2; simpl; unfold cin; auto.
  destruct o3; simpls; inverts L3; auto.
Defined.



Lemma red_inj_val' : forall b v1 o,
   before (out_ter 1 (val_inj b v1)) o ->
   red (trm_inj b v1) o.
Proof.
  intros. applys* red_inj. inverts* H.
Defined.



(*
Lemma red_tr_bind_abort : forall o2 o o1 t1 x k,
  correctness -> 
  red t1 o1 ->
  abort o1 -> 
  faster o1 o ->
  before o1 o2 ->
  before o2 o ->
  red (tr_bind (tr_trm t1) x k) (map cin (tr_out o)).
Proof.
  introv C R A F1 B1 B2. inverts A.
  inverts B1. inverts B2. inverts F1.
   applys* red_case. simpl. applys red_case_1_false.
   applys red_abs_beta. unfold tr_exn. simpl_subst.
   applys red_inj_val. auto. auto. done. 
  inverts F1. applys* red_case. 
Defined.
*)


Lemma red_tr_bind : forall o t1' o1 o1' x k f,
  red t1' o1' ->
  o1' = map f (tr_out o1) ->
  faster o1' o ->
  (match o1 with
    | out_ter _ (res_ret v1) =>
        exists o2,
        red (subst x (tr_val v1) k) o2 /\
        before (add 4%nat o2) o
    | out_ter _ (res_exn v1) =>
        before (add 5%nat o1') o
    | out_div => o = out_div 
    end) ->
  red (tr_bind t1' x k) o.
Proof.
  introv R1 E1 F1 M. destruct o1 as [n1 [v1|v1]|]; simpls.
  destruct M as (o2&R2&L2). subst o1'.
   applys red_case R1. applys red_case_1_true.
   applys red_abs_beta. eauto. auto. auto.
   destruct o2; inverts L2; simple~.
  subst o1'. applys red_case R1. applys red_case_1_false.
   applys red_abs_beta. unfold tr_exn. simpl_subst.
   applys red_inj_val. auto. auto. inverts M. inverts F1.
   unfolds cin. simpl. auto.
  subst o o1'. applys* red_case.
Defined.


(*
Fixpoint fresh (f:fresh_opt) (x:var) (t:trm) : trm :=
  match t with
  | trm_val v1 => True
  | trm_var y => If x = y then v else t
  | trm_abs y t3 => trm_abs y (If x = y then t3 else s t3)
  | trm_app t1 t2 => trm_app (s t1) (s t2)  
  | trm_inj b t1 => trm_inj b (s t1)
  | trm_case t1 t2 t3 => trm_case (s t1) (s t2) (s t3)
  | trm_try t1 t2 => trm_try (s t1) (s t2)
  | trm_raise t1 => trm_raise (s t1)
  end.
*) of "x does not occur free in t", written
    [fresh not_free x t] and "x does not occur at all in t",
    written [fresh not_used x t]. *)

Inductive not_fresh := not_used | not_free.

Inductive fresh : not_fresh -> var -> trm -> Prop :=
  | fresh_val : forall f x v,
      fresh f x (trm_val v) 
  | fresh_abs : forall f x y t3,
      fresh f x t3 ->
      x <> y -> 
      fresh f x (trm_abs y t3)
  | fresh_abs_free_eq : forall x t3,
      fresh not_free x (trm_abs x t3)
  | fresh_app : forall f x t1 t2,
      fresh f x t1 ->
      fresh f x t2 ->
      fresh f x (trm_app t1 t2)
  | fresh_inj : forall f x b t1,
      fresh f x t1 ->
      fresh f x (trm_inj b t1)
  | fresh_case : forall f x t1 t2 t3,
      fresh f x t1 ->
      fresh f x t2 ->
      fresh f x t3 ->
      fresh f x (trm_case t1 t2 t3)
  | fresh_try : forall f x t1 t2,
      fresh f x t1 ->
      fresh f x t2 ->
      fresh f x (trm_try t1 t2)
  | fresh_raise : forall f x t1,
      fresh f x t1 ->
      fresh f x (trm_raise t1).

Hint Constructors fresh.

(** "does not occur" implies "does not occur free" *)

Lemma fresh_not_used_not_free : forall x t,
  fresh not_used x t -> fresh not_free x t.
Proof. introv H. induction* H. Qed.

(** Substitution for a variable that does not occur
    free is the identity *)

Lemma subst_id : forall x v t, 
  fresh not_free x t -> 
  subst x v t = t. 
Proof. introv H. induction H; simpl; fequals; try case_if*. Qed.
*)


n E) l.

(*
Definition fresh_special t := 
  exists E, E = vars not_used t /\
  x1 \notin E /\ x2 \notin E /\ x3 \notin E.
*)



(*
Definition notins (l:list var) E :=
  Forall (fun x => x \notin E) l.

Lemma notins_union_inv : forall l E F,
  notins 
*)




(*
Lemma max_lr : forall p n m, p = max n m -> m <= p /\ n <= p.
Proof.
Qed.

Axiom max_inv : forall p n m, p = max n m -> m = p \/ n = p.


Lemma max_l : forall n m, n <= max n m.
Proof. Qed.

Axiom max_r : forall n m, m <= max n m.
*)

Axiom max_elim : forall n m, max n m <= n /\ max n m <= m /\ (max n m = n \/ max n m = m).









Guarded.
       introv A B.

rename IH into C.
rename R3 into R.
rename L4 into B1.
rename L2 into B2.
asserts F1: (faster o0 o2). 
 inverts B; inverts B1; done.
asserts B3: (before (map cin (tr_out o0)) (add 4 (map cin (tr_out o2)))). skip. 
rename Fr into Fr2.
(*
asserts Fr: (fresh (trm_vars not_used t2) 3 L). skip.
*)
clears t1. clear L1.
inverts A.
  inverts B1. inverts B2. (* inverts B3.*) inverts F1.
   applys red_case. Guarded. applys* C.
Guarded.
   simpl. applys red_case_1_false.
   applys red_abs_beta. unfold tr_exn. simpl_substs.
   applys red_inj_val. auto. auto. done. skip.
  inverts F1. inverts B3. applys* red_case. skip.

Guarded.
Set Printing Depth 5.
Guarded.
