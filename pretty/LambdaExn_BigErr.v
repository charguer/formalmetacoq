(************************************************************
* Lambda-calculus with exceptions,                          *
* Big-step semantics with error rules                       *
*************************************************************)

Set Implicit Arguments.
Require Export LambdaExn_Syntax.
Export BehaviorsWithErrors.
Export AssumeDeterministic.

Implicit Types v : val.
Implicit Types t : trm.
Implicit Types b : beh.

(*==========================================================*)
(* * Definitions *)

(************************************************************)
(* ** Semantics *)

(** Abort behaviors *)

Inductive abort : beh -> Prop := 
  | abort_exn : forall v, abort (beh_exn v)
  | abort_err : abort beh_err.

(** Characterisation of closures *)

Inductive isclo : val -> Prop :=
  | isclo_intro : forall x t3, isclo (val_clo x t3).

(** Reduction *)

Inductive bigred : trm -> beh -> Prop :=
  | bigred_var : forall x,
      bigred (trm_var x) beh_err
  | bigred_val : forall v,
      bigred v v
  | bigred_abs : forall x t,
      bigred (trm_abs x t) (val_clo x t)
  | bigred_app : forall t1 t2 x t3 v2 o,
      bigred t1 (val_clo x t3) ->
      bigred t2 v2 ->
      bigred (subst x v2 t3) o ->
      bigred (trm_app t1 t2) o
  | bigred_app_abort_1 : forall t1 t2 b,
      abort b ->
      bigred t1 b ->
      bigred (trm_app t1 t2) b
  | bigred_app_abort_2 : forall t1 t2 v1 b,
      abort b ->
      bigred t1 v1 ->
      bigred t2 b ->
      bigred (trm_app t1 t2) b
  | bigred_app_2_err : forall t1 t2 v1 v2,
      ~ isclo v1 ->
      bigred t1 v1 ->
      bigred t2 v2 ->
      bigred (trm_app t1 t2) beh_err
  | bigred_try : forall t1 t2 v1,
      bigred t1 v1 ->
      bigred (trm_try t1 t2) v1
  | bigred_try_1 : forall t1 t2 o2 v,
      bigred t1 (beh_exn v)->
      bigred (trm_app t2 v) o2 ->
      bigred (trm_try t1 t2) o2
  | bigred_try_1_err : forall t1 t2,
      bigred t1 beh_err ->
      bigred (trm_try t1 t2) beh_err
  | bigred_raise : forall t1 v1,
      bigred t1 v1 ->
      bigred (trm_raise t1) (beh_exn v1)
  | bigred_raise_abort_1 : forall t1 b,
      abort b ->
      bigred t1 b ->
      bigred (trm_raise t1) b
  | bigred_rand : forall k, 
      (ParamDeterministic -> k = 0) ->
      bigred trm_rand (val_int k).

(** Divergence *)

CoInductive bigdiv : trm -> Prop :=
  | bigdiv_app_1 : forall t1 t2,
      bigdiv t1 ->
      bigdiv (trm_app t1 t2) 
  | bigdiv_app_2 : forall t1 v1 t2,
      bigred t1 v1 ->
      bigdiv t2 ->
      bigdiv (trm_app t1 t2) 
  | bigdiv_app_3 : forall t1 t2 x t3 v2,
      bigred t1 (val_clo x t3) ->
      bigred t2 v2 ->
      bigdiv (subst x v2 t3) ->
      bigdiv (trm_app t1 t2) 
  | bigdiv_try_1 : forall t1 t2,
      bigdiv t1 ->
      bigdiv (trm_try t1 t2) 
  | bigdiv_try_2 : forall t1 t2 v,
      bigred t1 (beh_exn v) ->
      bigdiv (trm_app t2 v) ->
      bigdiv (trm_try t1 t2)
  | bigdiv_raise_1 : forall t1,
      bigdiv t1 ->
      bigdiv (trm_raise t1).

(** Auxiliary *)

Definition terminates t := exists b, bigred t b.


(*==========================================================*)
(* * Proofs *)

(************************************************************)
(* ** Induction principle on the height of a derivation *)

(** Ideally, would be automatically generated by Coq *)

Section BigredInd.

Inductive bigredh : nat -> trm -> beh -> Prop :=
  | bigredh_var : forall n x,
      bigredh (S n) (trm_var x) beh_err
  | bigredh_val : forall n v,
      bigredh (S n) v v
  | bigredh_abs : forall n x t,
      bigredh (S n) (trm_abs x t) (val_clo x t)
  | bigredh_app : forall n t1 t2 x t3 v2 b,
      bigredh n t1 (val_clo x t3) ->
      bigredh n t2 v2 ->
      bigredh n (subst x v2 t3) b ->
      bigredh (S n) (trm_app t1 t2) b
  | bigredh_app_abort_1 : forall n b t1 t2,
      abort b ->
      bigredh n t1 b ->
      bigredh (S n) (trm_app t1 t2) b
  | bigredh_app_abort_2 : forall n b t1 t2 v1,
      abort b ->
      bigredh n t1 v1 ->
      bigredh n t2 b ->
      bigredh (S n) (trm_app t1 t2) b
  | bigredh_app_2_err : forall n t1 t2 v1 v2,
      ~ isclo v1 ->
      bigredh n t1 v1 ->
      bigredh n t2 v2 ->
      bigredh (S n) (trm_app t1 t2) beh_err
  | bigredh_try : forall n t1 t2 v1,
      bigredh n t1 v1 ->
      bigredh (S n) (trm_try t1 t2) v1
  | bigredh_try_1 : forall n t1 t2 o2 v,
      bigredh n t1 (beh_exn v)->
      bigredh n (trm_app t2 v) o2 ->
      bigredh (S n) (trm_try t1 t2) o2
  | bigredh_try_1_err : forall n t1 t2,
      bigredh n t1 beh_err ->
      bigredh (S n) (trm_try t1 t2) beh_err
  | bigredh_raise : forall n t1 v1,
      bigredh n t1 v1 ->
      bigredh (S n) (trm_raise t1) (beh_exn v1)
  | bigredh_raise_abort_1 : forall n b t1,
      abort b ->
      bigredh n t1 b ->
      bigredh (S n) (trm_raise t1) b
  | bigredh_rand : forall n k, 
      (ParamDeterministic -> k = 0) ->
      bigredh (S n) trm_rand (val_int k).

Hint Constructors bigred bigredh.
Hint Extern 1 (_ < _) => math.

Lemma bigredh_lt : forall n n' t b,
  bigredh n t b -> n < n' -> bigredh n' t b.
Proof.
  introv H. gen n'. induction H; introv L; 
   (destruct n' as [|n']; [ false; math | auto* ]).
Qed.

Lemma bigred_bigredh : forall t b,
  bigred t b -> exists n, bigredh n t b.
Proof. hint bigredh_lt. introv H. induction H; try induct_height. Qed.

End BigredInd.


(************************************************************)
(* ** Determinacy property *)

Section Det.

Lemma abort_ret_false : forall v,
  abort (beh_ret v) -> False.
Proof. introv H. inverts H. Qed.

Hint Resolve abort_ret_false.
Hint Constructors isclo.

Lemma bigred_deterministic : forall t b1 b2,
  bigred t b1 -> bigred t b2 -> b1 = b2.
Proof.
  introv R. gen b2. induction R; introv D; inverts~ D.
  forwards* M: IHR1. inverts~ M.
   forwards* M: IHR2. inverts~ M.
  forwards* M: IHR1. inverts~ M.
   forwards* M: IHR2. inverts~ M. false*.
  forwards* M: IHR1. inverts~ M.
   forwards* M: IHR2. inverts~ M. false*.
  forwards* M: IHR1. inverts~ M.
   forwards* M: IHR2. inverts~ M. false*.
  forwards* M: IHR. inverts~ M. false*.
  forwards* M: IHR. inverts~ M. false*.
  forwards* M: IHR. inverts~ M. false*.
  forwards* M: IHR1. inverts~ M.
   forwards* M: IHR2. inverts~ M. false*.
  forwards* M: IHR1. inverts~ M. false*.
  forwards* M: IHR1. inverts~ M.
   forwards* M: IHR2. inverts~ M. false*.
  forwards* M: IHR1. inverts~ M.
   forwards* M: IHR2. inverts~ M. false* H.
  forwards* M: IHR1. inverts~ M. false*.
  forwards* M: IHR1. inverts~ M.
   forwards* M: IHR2. inverts~ M. false*.
  forwards* M: IHR. inverts~ M.
  forwards* M: IHR1. inverts~ M.
  forwards* M: IHR1. inverts~ M.
  forwards* M: IHR1. inverts~ M.
  forwards* M: IHR. inverts~ M.
  forwards* M: IHR. inverts~ M.
  forwards* M: IHR. inverts M. false*.
  forwards* M: IHR. inverts~ M. false*.
  rewrite Deterministic in *. rewrite~ H. rewrite~ H0.
Qed.

Lemma bigred_bigdiv_exclusive : forall t b,
  bigred t b -> bigdiv t -> False.
Proof.
  lets K: bigred_deterministic.
  introv R. induction R; introv D; inverts D; auto*.
  forwards* M: K R1. inverts~ M.
   forwards* M: K R2. inverts~ M.
  forwards* M: K R. inverts~ M. false*.
  forwards* M: K R. inverts~ M. false*.
  forwards* M: K R1. inverts~ M.
   forwards* M: K R2. inverts~ M. false*.
  forwards* M: K R1. inverts~ M.
  forwards* M: K R. inverts~ M.
  forwards* M: K R1. inverts~ M.
  forwards* M: K R. inverts~ M.
Qed.

End Det.


(************************************************************)
(* ** Full coverage property *)

Section Full.

(** Note: could be automated better using more advanced tactics *)

Hint Constructors bigred abort.
Hint Unfold terminates.

Lemma abort_or_val : forall b,
  abort b \/ exists v, b = beh_ret v.
Proof. intros. destruct* b. Qed.

Lemma not_terminates_bigdiv : forall t,
  ~ terminates t -> bigdiv t.
Proof.
  cofix IH. introv N. destruct t; try solve [ false* N ].
  tests (b1&R1) C1: (terminates t1). 
    lets [A1|(v1&E1)]: (abort_or_val b1).
      false* N.
      subst. tests (b2&R2) C2: (terminates t2). 
        lets [A2|(v2&E2)]: (abort_or_val b2).
          false* N.
          subst. tests C3: (~ isclo v1).
            false* N.
            inverts C3. tests (b4&R4) C4: (terminates (subst x v2 t3)).
              false *N.
              applys* bigdiv_app_3.
        applys* bigdiv_app_2.
    applys* bigdiv_app_1.
  tests (b1&R1) C1: (terminates t1). 
    destruct b1 as [v1|v| ].
      false* N.
      tests (b2&R2) C2: (terminates (trm_app t2 v)). 
        false* N.
        applys* bigdiv_try_2.
      false* N.
    applys* bigdiv_try_1.
  tests (b1&R1) C1: (terminates t). 
    lets [A1|(v1&E1)]: (abort_or_val b1).
      false* N.
      subst. false* N.
    applys* bigdiv_raise_1.
Qed.

End Full.





